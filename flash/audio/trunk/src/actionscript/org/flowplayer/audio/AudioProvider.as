/*     *    Copyright 2008 Anssi Piirainen * *    This file is part of FlowPlayer. * *    FlowPlayer is free software: you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation, either version 3 of the License, or *    (at your option) any later version. * *    FlowPlayer is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with FlowPlayer.  If not, see <http://www.gnu.org/licenses/>. */package org.flowplayer.audio {	import flash.events.ProgressEvent;		import flash.events.TimerEvent;		import flash.utils.Timer;		import flash.events.Event;			import org.flowplayer.util.Log;		import org.flowplayer.controller.StreamProvider;	import org.flowplayer.controller.VolumeController;	import org.flowplayer.model.Clip;	import org.flowplayer.model.ClipEvent;	import org.flowplayer.model.ClipEventType;	import org.flowplayer.model.Playlist;		import flash.display.DisplayObject;	import flash.media.Sound;	import flash.net.URLRequest;	import flash.media.SoundTransform;	import flash.media.SoundChannel;			/**	 * @author api	 */	public class AudioProvider implements StreamProvider {		private var log:Log = new Log(this);		private var _sound:Sound;		private var _playing:Boolean;		private var _paused:Boolean;		private var _durationCalculated:Boolean;		private var _durationSeconds:Number;		private var _clip:Clip;		private var _pausedPosition:Number;		private var _soundTransform:SoundTransform;		private var _channel:SoundChannel;		private var _playlist:Playlist;		private var _progressTimer:Timer;		private var _seeking:Boolean;		public function AudioProvider() {			_sound = new Sound();		}		public function stopBuffering():void {			_sound.close();			resetState();		}				public function stop(event:ClipEvent, closeStream:Boolean = false):void {			_channel.stop();			if (closeStream) {				_sound.close();			}			resetState();		}				private function resetState():void {			_playing = false;			_paused = false;			_durationCalculated = false;			_durationSeconds = 0;		}		public function attachStream(video:DisplayObject):void {		}				public function load(event:ClipEvent, clip:Clip, pauseAfterStart:Boolean = true):void {			log.debug("load()");			_clip = clip;			_durationCalculated = false;			_pausedPosition = 0;			addListeners(_sound);			_sound.load(new URLRequest(clip.completeUrl));			play(0);			if (pauseAfterStart) {				log.debug("AudioProvider: not playing yet (only buffering), pausing playback");				_paused = true;				_channel.stop();			}		}				private function addListeners(sound:Sound):void {			sound.addEventListener(ProgressEvent.PROGRESS, onProgress);			sound.addEventListener(Event.SOUND_COMPLETE, onComplete);			_progressTimer = new Timer(200);			_progressTimer.addEventListener(TimerEvent.TIMER, onProgressTimer);			_progressTimer.start();		}		private function onProgress(event:ProgressEvent):void {			if (_playing) return;			_playing = true;			_clip.dispatch(ClipEventType.BEGIN);			_clip.dispatch(ClipEventType.START);		}		private function onProgressTimer(event:TimerEvent):void {			log.debug("onProgressTimer");			estimateDuration();    		    		if (! _sound.bytesTotal > 0) return;    		if (! _sound.bytesLoaded > 0) return;			if(_sound.isBuffering == true && _sound.bytesTotal > _sound.bytesLoaded) {				_clip.dispatch(ClipEventType.BUFFER_EMPTY);			} else{				_clip.dispatch(ClipEventType.BUFFER_FULL);				_progressTimer.stop();			}		}				private function estimateDuration():void {    		var durationSecs:Number = (_sound.length/(_sound.bytesLoaded/_sound.bytesTotal))/1000;    		_clip.duration = durationSecs;		}		private function onComplete(event:Event):void {			// dispatch a before event because the finish has default behavior that can be prevented by listeners			_clip.dispatchBeforeEvent(new ClipEvent(ClipEventType.FINISH));			_progressTimer.stop();		}		public function getVideo(clip:Clip):DisplayObject {			return null;		}				public function resume(event:ClipEvent):void {			log.debug("resume");			_paused = false;			play(_pausedPosition);			_clip.dispatch(ClipEventType.RESUME);		}				public function pause(event:ClipEvent):void {			log.debug("pause");			_paused = true;			_pausedPosition = _channel.position; 			_channel.stop();			_clip.dispatch(ClipEventType.PAUSE);		}		public function seek(event:ClipEvent, seconds:Number):void {			_channel.stop();			_seeking = true;			play(seconds * 1000);			_clip.dispatch(ClipEventType.SEEK, time);			if (_paused) {				_pausedPosition = _channel.position; 				_channel.stop();			} 		}				private function play(posMillis:Number):void {			_channel = _sound.play(posMillis, 0, _soundTransform);		}		public function get stopping():Boolean {			return false;		}				public function get allowRandomSeek():Boolean {			return false;		}				public function get bufferStart():Number {			return 0;		}				public function get playlist():Playlist {			return _playlist;		}		public function get time():Number {			return _channel.position / 1000;		}		public function get bufferEnd():Number {			return _sound.bytesLoaded / _sound.bytesTotal * _clip.duration;		}		public function get fileSize():Number {			return _sound.bytesLoaded;		}				public function set playlist(playlist:Playlist):void {			_playlist = playlist;		}				public function set netStreamClient(client:Object):void {		}				public function set volumeController(controller:VolumeController):void {			_soundTransform = controller.soundTransform;		}	}}