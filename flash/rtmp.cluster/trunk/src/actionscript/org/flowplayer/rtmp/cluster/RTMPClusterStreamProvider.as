/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com> * Copyright (c) 2008 Electroteque Multimedia * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.rtmp.cluster {		import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.SharedObject;	import flash.utils.Timer;	import mx.utils.URLUtil;		import org.flowplayer.model.Clip;	import org.flowplayer.model.ClipEvent;	import org.flowplayer.model.Plugin;	import org.flowplayer.model.PluginModel;	import org.flowplayer.rtmp.RTMPStreamProvider;	import org.flowplayer.util.PropertyBinder;			import org.flowplayer.rtmp.cluster.event.RTMPEventType;		/**	 * A RTMP stream provider with fallback and clustering support. Supports following:	 * <ul>	 * <li>Starting in the middle of the clip's timeline using the clip.start property.</li>	 * <li>Stopping before the clip file ends using the clip.duration property.</li>	 * <li>Ability to combine a group of clips into one gapless stream.</li>	 * <li>Ability to fallback to a list of servers in a cluster server farm.</li>	 * <li>Ability to recognise, store and leave out any failed servers for a given time.</li>	 * <li>Ability to randomly connect to a server in the servers list mimicking a round robin connection.</li>	 * <li>Works with a traditional load balancing appliance by feeding its host at the top of the list, and direct connections to the servers happen on fallback.</li>	 * </ul>	 * <p>	 * Stream group is configured in a clip like this:	 * <code>	 * { streams: [ { url: 'metacafe', duration: 20 }, { url: 'honda_accord', start: 10, duration: 20 } ] }	 * </code>	 * The group is played back seamlessly as one gapless stream. The individual streams in a group can	 * be cut out from a larger file using the 'start' and 'duration' properties as shown in the example above.	 * 	 * <p> 	 * To enable server fallback a hosts config property is required in the plugins config like this:	 * 	 * hosts: [	 *	       'rtmp://server1.host.com/myapp',	 *	       'rtmp://server2.host.com/myapp',	 *	       'rtmp://server3.host.com/myapp',	 *	      ]	 * 	 * <p>	 * To enable the fallback feature to store (client side) failed servers to prevent reattempting those connections the failureExpiry config property is required like so:	 * failureExpiry: 3000,	 * 	 * <p> This tells the feature to wait for 3000 milliseconds before allowing connection attempts again. 	 * 	 * <p>	 * To enable round robin connections the loadBalanceServers config property requires to be enabled like so:	 * 	 * loadBalanceServers: true	 * 	 * <p>	 * Advanced configurations for the fallback feature can be enabled like so:	 * 	 * connectTimeout: 5000,	 * connectCount: 3	 * encoding: 0	 * 	 * <p> connectTimeout is the time in milliseconds before each reconnection attempt.	 * connectCount is the ammount of times connection reattmps will occur before giving up.	 * encoding is the AMF encoding version either 0 or 3 for AMF3.	 * 	 * <p> Two custom events a fired during connection attempts and fallback, these are:	 * 	 * <ul>	 * <li>RTMPEventType.RECONNECTED - onReconnect</li>	 * <li>RTMPEventType.FAILED - onFailed</li>	 * </ul>	 * 	 * @author danielr	 */	public class RTMPClusterStreamProvider extends RTMPStreamProvider implements Plugin {		private var _config:RTMPClusterConfig;		protected var _timer:Timer;		protected var _hostIndex:int = 0;		protected var _connectCount:int = 0;		protected var _liveServers:Array;		protected var _liveRandomServers:Array = [];		private var _startAfterConnect:Boolean;						/**		 * Called by the player to set my model object.		 */		override public function onConfig(model:PluginModel):void {			super.onConfig(model);			_config = new PropertyBinder(new RTMPClusterConfig(), null).copyProperties(model.config) as RTMPClusterConfig;						//On startup we get a list of available online servers			liveServers = getHosts();		}				/**		 * Set the object encoding version		 */		protected function setObjectEncoding():void		{						switch (_config.encoding)			{				case 0:					NetConnection.defaultObjectEncoding = flash.net.ObjectEncoding.AMF0;				break;				default:					NetConnection.defaultObjectEncoding = flash.net.ObjectEncoding.DEFAULT;				break;			}		}				/**		 * A filter callback called from getHosts to determine if the server is live or failed		 */		protected function checkLiveHost(element:*, index:int, arr:Array):Boolean		{			return isLiveServer(element);		}				/**		 * Set the live servers list		 */		protected function set liveServers(hosts:Array):void		{			_liveServers = hosts;		}				/**		 * Get a list of available online servers		 */		protected function getHosts():Array		{			return _config.hosts.filter(checkLiveHost);		}				/**		 * Return the host in the live given by an index		 */		protected function getHost(index:int):String		{			return _liveServers[index];		}				/**		 * Setup the timers for the fallback feature		 */		protected function setupFallback():void		{			_timer = new Timer(_config.connectTimeout, getHosts().length);			_timer.addEventListener(TimerEvent.TIMER_COMPLETE , tryFallBack);		}				/**		 * Override connect to setup fallback feature		 */		override protected function connect(clip:Clip, startAfterConnect:Boolean = false, ... rest):void {			_startAfterConnect = startAfterConnect;			setObjectEncoding();			setupFallback();			log.info("Starting Connection");			if (rest.length > 0)			{				super.connect(clip, startAfterConnect, rest);			} else if (_config.connectionArgs) {				super.connect(clip, startAfterConnect, _config.connectionArgs);			} else {				super.connect(clip, startAfterConnect);			}			nextConnect();		}				/**		 * Gets the connection URI to connect to the media server app. 		 * URI is determined if multiple hosts are enabled or if round robin is enabled.		 */		override protected function getConnectUrl(clip:Clip):String {						if (clip.customProperties && clip.customProperties.netConnectionUrl) {				return clip.customProperties.netConnectionUrl;			}						// If round robin is enabled and there are multiple live hosts setup random connection			if (_config.loadBalanceServers && hasMultipleHosts())			{				var index:uint = getRandomIndex();				_hostIndex = index;				return getHost(index);			} else if (hasMultipleHosts()) {				// If we have multiple live hosts				return getHost(_hostIndex);			}						// We don't have round robin or fallbacks enabled just return the netConnectionUrl			return _config.netConnectionUrl;		}				/**		 * Check to see if the available online servers list is enabled		 */		protected function hasMultipleHosts():Boolean		{			return _liveServers.length > 0;		}				/**		 * Returns a random index used by the round robin feature		 */		protected function getRandomIndex():uint		{			return Math.round(Math.random() * (_liveServers.length - 1));		}				/**		 * Starts loading using the specified netStream and clip.		 */		override protected function doLoad(event:ClipEvent, netStream:NetStream, clip:Clip):void {			if (hasStreamGroup(clip)) {				startStreamGroup(clip, netStream);			} if (clip.start > 0) {				netStream.play(getClipUrl(clip), clip.start, clip.duration > 0 ? clip.duration : -1);			} else {				// TODO: Red5 requires 0 or else it thinks its a live stream, need to possible determine if its VOD or not ??				netStream.play(getClipUrl(clip),0);				//super.doLoad(event, netStream, clip);			}		}		/**		 * This is overriden because by default the player always adds the HTML page's path as a baseUrl, and we don't want		 * that with RTMP. If baseUrl is available that will be included in completeUrl and that's fine.		 */		override protected function getClipUrl(clip:Clip):String {			return clip.baseUrl ? clip.completeUrl : clip.url;		}				/**		 * Override netStatus to turn off the fallback feature if a connection is successful		 */		override protected function onNetStatus(event:NetStatusEvent):void 		{						switch (event.info.code) 			{				//connection is successful stop any reconnection attempts				case "NetConnection.Connect.Success":					stopReconnect();				break;				//connection has failed, reattempt using the fallback system				case "NetConnection.Connect.Failed":					log.info("Couldnt connect to " + netConnection.uri);				break;				//connection has closed				case "NetConnection.Connect.Closed":					break;			}						log.debug(event.info.code);		}				override protected function canDispatchStreamNotFound():Boolean {			// overridden so that onStreanNotFound is not dispatched			return false;		}				/**		 * Clear the timeout interval		 * 		 * @return	void		 */		protected function stopReconnect():void		{			if (_timer.running) _timer.stop();		}				/**		 * Setup the fallback connection system and call the tryFallback method after a certain retry interval		 * 		 * @return	void		 */		protected function nextConnect():void		{			if (!_timer.running && hasMultipleHosts())			{				_timer.start();			}		}				/**		 * Determines if there is more available online servers for reconnection attempts		 */		protected function hasMoreHosts():Boolean		{			_hostIndex++;			liveServers = getHosts();						if (_hostIndex >= _liveServers.length)			{ 				//log.error("Host Index: " + _hostIndex + " LiveServers: " + _liveServers.length);				_connectCount++;				if (_connectCount < _config.connectCount) 				{					log.error("Restarting Connection Attempts");					_hostIndex = 0;				}			}			return (_hostIndex <= _liveServers.length && getHost(_hostIndex));		}				/**		 * Gets the failed server SharedObject		 */		protected function getFailedServerSO(host:String):SharedObject		{			var domain:String = URLUtil.getServerName(host);			return SharedObject.getLocal(domain,"/");		}				/**		 * Determines if the server is live or a failed server.		 */		protected function isLiveServer(host:String):Boolean		{			var server:SharedObject = getFailedServerSO(host);						// Server is failed, determine if the failure expiry interval has been reached and clear it			if (server.data.failureTimestamp)			{				var date:Date = new Date();									// Determine the failure offset				var offset:int = (date.getTime() - server.data.failureTimestamp.getTime()) / 60; 								log.info("Failed Server Remaining Expiry: " + offset + " Start Time: " + server.data.failureTimestamp.getTime() + " Current Time: " + date.getTime());								// Failure offset has reached the failureExpiry setting, clear it from the list to allow a connection				if (offset >= _config.failureExpiry)				{					log.info("Clearing Failure Period");					server.clear();					return true;				} 				return false;			}			return true;		}				/**		 * Set the server as failed		 */		protected function setFailedServer(host:String):void		{			 var server:SharedObject = getFailedServerSO(host);			 server.data.failureTimestamp = new Date();		}				/**		 * Fallback feature method called by the reconnection attempt timer		 */		protected function tryFallBack(e:TimerEvent):void		{			netConnection.proxyType = "none";			//log.info("Failed connection to " + netConnection.uri);						// Set this server as failed to prevent reconnections to it			setFailedServer(netConnection.uri);						// Check if there is more hosts to attempt reconnection to			if (hasMoreHosts())			{								dispatchEvent(new ClipEvent(RTMPEventType.RECONNECTED));				log.info("Attempting reconnection");				netConnection.close();				connect(clip,_startAfterConnect);			} else {				// we have reached the end of the hosts list stop reconnection attempts and send a failed event				stopReconnect();				log.info("Connections failed");				dispatchEvent(new ClipEvent(RTMPEventType.FAILED));			}		}	}}