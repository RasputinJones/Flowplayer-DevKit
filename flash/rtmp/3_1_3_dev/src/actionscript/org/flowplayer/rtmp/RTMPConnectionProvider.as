/*     *    Copyright 2008 Anssi Piirainen * *    This file is part of FlowPlayer. * *    FlowPlayer is free software: you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation, either version 3 of the License, or *    (at your option) any later version. * *    FlowPlayer is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with FlowPlayer.  If not, see <http://www.gnu.org/licenses/>. */package org.flowplayer.rtmp {    import flash.events.NetStatusEvent;    import flash.events.NetStatusEvent;    import flash.events.TimerEvent;    import flash.net.NetConnection;    import flash.utils.Timer;    import org.flowplayer.controller.ConnectionProvider;    import org.flowplayer.controller.DefaultRTMPConnectionProvider;    import org.flowplayer.controller.NetStreamControllingStreamProvider;    import org.flowplayer.controller.StreamProvider;    import org.flowplayer.model.Clip;    import org.flowplayer.model.Clip;    import org.flowplayer.util.Log;    /**	 * @author api	 */	public class RTMPConnectionProvider implements ConnectionProvider {        protected var log:Log = new Log(this);//		private var _config:Config;        private var _proxyType:String;        private var _netConnectionUrl:String;        private var _successListener:Function;        private var _failureListener:Function;        private var _connectionClient:Object;        private var _connector1:Connector;        private var _connector2:Connector;        private var _connection:NetConnection;        public function RTMPConnectionProvider(proxyType:String, netConnectionUrl:String) {            _proxyType = proxyType;            _netConnectionUrl = netConnectionUrl;        }        public function connect(ignored:StreamProvider, clip:Clip, successListener:Function, objectEncoding: uint, ... rest):void {                        _successListener = successListener;            _connection = null;            var configuredUrl:String = getNetConnectionUrl(clip)            var parts:Array = getUrlParts(configuredUrl);            if (parts && parts[0] == 'rtmp') {                log.debug("will connect using RTMP and RTMPT in parallel");                _connector1 = new Connector('rtmp://' + parts[1], _connectionClient, onConnectorSuccess, onConnectorFailure);                _connector2 = new Connector('rtmpt://' + parts[1], _connectionClient, onConnectorSuccess, onConnectorFailure);                doConnect(_connector1, _proxyType, objectEncoding, rest);                // RTMPT connect is started after 250 ms                var delay:Timer = new Timer(250, 1);                delay.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {                    doConnect(_connector2, _proxyType, objectEncoding, rest);                });                delay.start();            } else {                log.debug("connecting to URL "+ configuredUrl);                _connector1 = new Connector(configuredUrl, _connectionClient, onConnectorSuccess, onConnectorFailure);                doConnect(_connector1, _proxyType, objectEncoding, rest);            }        }        private function doConnect(connector1:Connector, proxyType:String, objectEncoding:uint, rest:Array):void {            if (rest.length > 0) {                connector1.connect(_proxyType, objectEncoding, rest);            } else {                connector1.connect(_proxyType, objectEncoding);            }        }        private function onConnectorSuccess(connector:Connector, connection:NetConnection):void {            log.debug(connector + " established a connection");            if (_connection) return;            _connection = connection;                        if (connector == _connector2 && _connector1) {                _connector1.stop();            } else if (_connector2) {                _connector2.stop();            }            _successListener(connection);        }        private function onConnectorFailure():void {            if (_failureListener != null) {                _failureListener();            }        }        private function getUrlParts(url:String):Array {            var pos:int = url.indexOf('://');            if (pos > 0) {                return [url.substring(0, pos), url.substring(pos + 3)];            }            return null;        }		private function getNetConnectionUrl(clip:Clip):String {			if (RTMPClipURLResolver.isRtmpUrl(clip.completeUrl)) {                log.debug("clip has complete rtmp url");				var url:String = clip.completeUrl;				var lastSlashPos:Number = url.lastIndexOf("/");				return url.substring(0, lastSlashPos);			}			if (clip.customProperties && clip.customProperties.netConnectionUrl) {				return clip.customProperties.netConnectionUrl;			}			return _netConnectionUrl;		}        public function set connectionClient(client:Object):void {            _connectionClient = client;        }        public function set onFailure(listener:Function):void {            _failureListener = listener;        }        public function handeNetStatusEvent(event:NetStatusEvent):Boolean {            return true;        }        public function get connection():NetConnection {            return _connection;        }    }}