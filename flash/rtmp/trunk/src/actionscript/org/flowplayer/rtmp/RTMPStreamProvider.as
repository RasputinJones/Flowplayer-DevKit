/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008 Flowplayer Ltd * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.rtmp {	import flash.net.NetStream;		import org.flowplayer.controller.NetStreamControllingStreamProvider;	import org.flowplayer.model.Clip;	import org.flowplayer.model.ClipEvent;	import org.flowplayer.model.Plugin;	import org.flowplayer.model.PluginModel;	import org.flowplayer.util.PropertyBinder;	import org.flowplayer.view.Flowplayer;		/**	 * A RTMP stream provider. Supports following:	 * <ul>	 * <li>Starting in the middle of the clip's timeline using the clip.start property.</li>	 * <li>Stopping before the clip file ends using the clip.duration property.</li>	 * <li>Ability to combine a group of clips into one gapless stream.</li>	 * </ul>	 * <p>	 * Stream group is configured in a clip like this:	 * <code>	 * { streams: [ { url: 'metacafe', duration: 20 }, { url: 'honda_accord', start: 10, duration: 20 } ] }	 * </code>	 * The group is played back seamlessly as one gapless stream. The individual streams in a group can	 * be cut out from a larger file using the 'start' and 'duration' properties as shown in the example above.	 * 	 * @author api	 */	public class RTMPStreamProvider extends NetStreamControllingStreamProvider implements Plugin {		private var _config:Config;				/**		 * Called by the player to set my model object.		 */		public function onConfig(model:PluginModel):void {			_config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;		}				/**		 * Called by the player to set the Flowplayer API.		 */		public function onLoad(player:Flowplayer):void {//			player.playlist.onMetaData(onMetaData, function(clip:Clip):Boolean { return clip.provider == _name; });		}		/**		 * Gets the connection URI to connect to the media server app.		 */		override protected function getConnectUrl(clip:Clip):String {			if (clip.customProperties && clip.customProperties.netConnectionUrl) {				return clip.customProperties.netConnectionUrl;			}			return _config.netConnectionUrl;		}		/**		 * Overridden to allow random seeking in the timeline.		 */		override public function get allowRandomSeek():Boolean {			return true;		}				/**		 * Starts loading using the specified netStream and clip.		 */		override protected function doLoad(event:ClipEvent, netStream:NetStream, clip:Clip):void {			if (hasStreamGroup(clip)) {				startStreamGroup(clip, netStream);			} if (clip.start > 0) {				netStream.play(getClipUrl(clip), clip.start, clip.duration > 0 ? clip.duration : -1);			} else {				netStream.play(getClipUrl(clip));//				netStream.play(getClipUrl(clip), 0, -1, true);			}		}		/**		 * This is overriden because by default the player always adds the HTML page's path as a baseUrl, and we don't want		 * that with RTMP. If baseUrl is available that will be included in completeUrl and that's fine.		 */		override protected function getClipUrl(clip:Clip):String {			return clip.baseUrl ? clip.completeUrl : clip.url;		}				/**		 * Starts streaming a stream group.		 */		protected function startStreamGroup(clip:Clip, netStream:NetStream):void {			var streams:Array = clip.customProperties.streams as Array;			log.debug("starting a group of " + streams.length + " streams");			var totalDuration:int = 0;			for (var i:Number = 0; i < streams.length; i++) {				var stream:Object = streams[i];				var duration:int = getDuration(stream);				var reset:Object = i == 0 ? 1 : 0; 				netStream.play(stream.url, getStart(stream), duration, reset);				if (duration > 0) {					totalDuration += duration;				}				log.debug("added " + stream.url + " to playlist, total duration " + totalDuration);			}			if (totalDuration > 0) {				clip.duration = totalDuration;			}		}		/**		 * Does the specified clip have a configured stream group?		 */		protected function hasStreamGroup(clip:Clip):Boolean {			return clip.customProperties && clip.customProperties.streams;		}		private function getDuration(stream:Object):int {			return stream.duration || -1;		}		private function getStart(stream:Object):int {			return stream.start || 0;		}				public function getDefaultConfig():Object {			return null;		}	}}