/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008 Flowplayer Ltd * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.rtmp {	import org.flowplayer.controller.ClipURLResolver;	import org.flowplayer.controller.ConnectionProvider;	import org.flowplayer.controller.NetStreamControllingStreamProvider;	import org.flowplayer.model.Clip;	import org.flowplayer.model.ClipEvent;	import org.flowplayer.model.Plugin;	import org.flowplayer.model.PluginModel;    import org.flowplayer.util.PropertyBinder;	import org.flowplayer.view.Flowplayer;    import org.flowplayer.model.PluginEventType;		import flash.net.NetStream;		/**	 * A RTMP stream provider. Supports following:	 * <ul>	 * <li>Starting in the middle of the clip's timeline using the clip.start property.</li>	 * <li>Stopping before the clip file ends using the clip.duration property.</li>	 * <li>Ability to combine a group of clips into one gapless stream.</li>	 * </ul>	 * <p>	 * Stream group is configured in a clip like this:	 * <code>	 * { streams: [ { url: 'metacafe', duration: 20 }, { url: 'honda_accord', start: 10, duration: 20 } ] }	 * </code>	 * The group is played back seamlessly as one gapless stream. The individual streams in a group can	 * be cut out from a larger file using the 'start' and 'duration' properties as shown in the example above.	 * 	 * @author api	 */	public class RTMPStreamProvider extends NetStreamControllingStreamProvider implements Plugin {		private var _config:Config;		private var _model:PluginModel;		private var _bufferStart:Number = 0;        private var _player:Flowplayer;		/**		 * Called by the player to set my model object.		 */		override public function onConfig(model:PluginModel):void {			if (_model) return;			_model = model;			_config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;		}		/**		 * Called by the player to set the Flowplayer API.		 */		override public function onLoad(player:Flowplayer):void {            _player = player;            log.debug("haloo");            if (_config.streamCallbacks) {                log.debug("configuration has " + _config.streamCallbacks + " stream callbacks");            } else {                log.debug("no stream callbacks in config");            }            createCallbacks(_config.connectionCallbacks, _player.addConnectionCallback);            createCallbacks(_config.streamCallbacks, _player.addStreamCallback);            _player.playlist.onConnectionEvent(onConnectionEvent, function(clip:Clip):Boolean { return clip.provider == _model.name;  });            _player.playlist.onNetStreamEvent(onStreamEvent, function(clip:Clip):Boolean { return clip.provider == _model.name;  });			_model.dispatchOnLoad();//			_model.dispatchError(PluginError.INIT_FAILED, "failed for no fucking reason");		}        private function onConnectionEvent(event:ClipEvent):void {            if (event.info != "registerCallback") return;            var name:String = event.info2 as String;            log.debug("recieved NetConnection.registerCallback for name " + name);            _player.addConnectionCallback(name, createCallbackListener(name));        }        private function onStreamEvent(event:ClipEvent):void {            if (event.info != "registerCallback") return;            var name:String = event.info2 as String;            log.debug("recieved NetStream.registerCallback for name " + name);            _player.addStreamCallback(name, createCallbackListener(name));        }        private function createCallbacks(callbacks:Array, registerFunc:Function):void {            if (! callbacks) return;            log.debug("registering "+callbacks.length+" callbakcs");            for (var i:int = 0; i < callbacks.length; i++) {                var name:String = callbacks[i];                registerFunc(name, createCallbackListener(name));            }        }        private function createCallbackListener(name:String):Function {            return function(infoObj:Object):void {                log.debug("received callback " + name);//                for (var name:String in infoObj) {//                    log.debug(name + ": " + infoObj[name]);//                }//                for (var param:String in infoObj.parameters) {//                    log.debug(param + ": " + infoObj.parameters[param]);//                }                _model.dispatch(PluginEventType.PLUGIN_EVENT, name, infoObj);            };        }        /**		 * Gets the connection URI to connect to the media server app.		 */		override protected function getDefaultConnectionProvider():ConnectionProvider {			if (_config.subscribe) {				log.debug("using FCSubscribe to connect");			}			return _config.subscribe ? new SubscribingRTMPConnectionProvider(_config) : new RTMPConnectionProvider(_config);		} 			/**		 * Overridden to allow random seeking in the timeline.		 */		override public function get allowRandomSeek():Boolean {			return true;		}				/**		 * Starts loading using the specified netStream and clip.		 */		override protected function doLoad(event:ClipEvent, netStream:NetStream, clip:Clip):void {			if (hasStreamGroup(clip)) {				startStreamGroup(clip, netStream);			} else {				resolveClipUrl(clip, onClipUrlResolved);			}		}				private function onClipUrlResolved(url:String):void {			if (clip.start > 0) {				netStream.play(url, clip.start, clip.duration > 0 ? clip.duration : -1);			} else {				netStream.play(url);			}		}		/**		 * This is overriden because by default the player always adds the HTML page's path as a baseUrl, and we don't want		 * that with RTMP. If baseUrl is available that will be included in completeUrl and that's fine.		 */		override protected function getDefaultClipURLResolver():ClipURLResolver {			return new RTMPClipURLResolver();		}				/**		 * Overridden to be able to store the latest seek target position.		 */		override protected function doSeek(event:ClipEvent, netStream:NetStream, seconds:Number):void {			_bufferStart = seconds;			super.doSeek(event, netStream, seconds);		}				override public function get bufferStart():Number {			if (! clip) return 0;			return _bufferStart;		}		override public function get bufferEnd():Number {			if (! netStream) return 0;			if (! clip) return 0;			return bufferStart + netStream.bufferLength;		}		/**		 * Starts streaming a stream group.		 */		protected function startStreamGroup(clip:Clip, netStream:NetStream):void {			var streams:Array = clip.customProperties.streams as Array;			log.debug("starting a group of " + streams.length + " streams");			var totalDuration:int = 0;			for (var i:Number = 0; i < streams.length; i++) {				var stream:Object = streams[i];				var duration:int = getDuration(stream);				var reset:Object = i == 0 ? 1 : 0; 				netStream.play(stream.url, getStart(stream), duration, reset);				if (duration > 0) {					totalDuration += duration;				}				log.debug("added " + stream.url + " to playlist, total duration " + totalDuration);			}			if (totalDuration > 0) {				clip.duration = totalDuration;			}		}		/**		 * Does the specified clip have a configured stream group?		 */		protected function hasStreamGroup(clip:Clip):Boolean {			return clip.customProperties && clip.customProperties.streams;		}		private function getDuration(stream:Object):int {			return stream.duration || -1;		}		private function getStart(stream:Object):int {			return stream.start || 0;		}				public function getDefaultConfig():Object {			return null;		}	}}