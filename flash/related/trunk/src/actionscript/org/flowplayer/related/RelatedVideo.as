/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com> * Copyright (c) 2009 Electroteque Multimedia * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.related {    import com.adobe.serialization.json.JSON;    import flash.display.BlendMode;    import flash.display.Sprite;    import flash.events.MouseEvent;    import flash.text.AntiAliasType;    import flash.text.TextField;    import org.flowplayer.controller.ResourceLoader;    import org.flowplayer.controller.ResourceLoaderImpl;    import org.flowplayer.model.Clip;    import org.flowplayer.model.ClipEvent;    import org.flowplayer.model.DisplayPluginModel;    import org.flowplayer.model.DisplayProperties;    import org.flowplayer.model.Plugin;    import org.flowplayer.model.PluginEventType;    import org.flowplayer.model.PluginModel;    import org.flowplayer.related.assets.MaximizeBtn;    import org.flowplayer.util.PropertyBinder;    import org.flowplayer.view.AbstractSprite;    import org.flowplayer.view.Flowplayer;    /**	 * A Subtitling and Captioning Plugin. Supports the following:	 * <ul>	 * <li>Loading subtitles from the Timed Text or Subrip format files.</li>	 * <li>Styling text from styles set in the Time Text format files.</li>	 * <li>Loading subtitles or cuepoints from a JSON config.</li>	 * <li>Loading subtitles or cuepoints from embedded FLV cuepoints.</li>	 * <li>Controls an external content plugin.</li>	 * <li>Working with the Javascript captions plugin, it enables a scrolling cuepoint thumbnail menu.</li>	 * </ul>	 * <p>	 * To setup an external subtitle caption file the config would look like so:	 * 	 * captionType: 'external'	 * 	 * For Timed Text	 *	 * captionUrl: 'timedtext.xml'	 * 	 * For Subrip	 * 	 * captionUrl: 'subrip.srt'	 * 	 * <p>	 * To enable the captioning to work properly a caption target must link to a content plugin like so:	 * 	 * captionTarget: 'content'	 * 	 * Where content is the config for a loaded content plugin.	 *	 * <p>	 * 	 * To be able to customised the subtitle text a template string is able to tell the captioning plugin	 * which text property is to be used for the subtitle text which is important for embedded cuepoints. It also	 * enables to add extra properties to the text like so:	 * 	 * template: '{text} {time} {custom}' 	 * 	 * <p>	 * To enable simple formatting of text if Timed Text has style settings, 	 * only "fontStyle", "fontWeight" and "textAlign" properties are able to be set like so:	 * 	 * simpleFormatting: true	 * 	 * @author danielr	 */	public class RelatedVideo extends AbstractSprite implements Plugin {				private var _player:Flowplayer;		private var _model:PluginModel;		private var _config:Config;		private var _loader:ResourceLoader;		private var _relatedClips:Array;		private var oldDisplayProperties:DisplayProperties;		private var _isRelatedVideosOpen:Boolean = false;		private var coverFlow:CoverFlow;		private var _currentIndex:Number = 0;		private var _viewModel:DisplayPluginModel;		private var _captionView:*;		private var _text:TextField;		private var _pageResults:String;		private var screen:DisplayProperties;		private var _coverFlowData:Array;        private var _defaultRelated:Array;        private var _showingClips:Array;		private var maximizeBtn:Sprite;		/**		 * Sets the plugin model. This gets called before the plugin		 * has been added to the display list and before the player is set.		 * @param plugin		 */		public function onConfig(plugin:PluginModel):void {			_model = plugin;			_config = new PropertyBinder(new Config(), null).copyProperties(plugin.config) as Config;		}				override protected function onResize():void {            _text.x = 10;            _text.width = width - 20;            coverFlow.width = stage.width;            coverFlow.height = height;            coverFlow.y = 0;            coverFlow.x = 0;            _text.y = height - 30;//            _text.y = coverFlow.y + height;        }		private function createTextField():void {			if (_text) {				removeChild(_text);			} 			_text = _player.createTextField();			_text.blendMode = BlendMode.LAYER;//			_text.autoSize = TextFieldAutoSize.CENTER;			_text.wordWrap = false;			_text.multiline = false;			_text.antiAliasType = AntiAliasType.ADVANCED;			_text.condenseWhite = true;					_text.visible = false;			addChild(_text);		}		public function onLoad(player:Flowplayer):void {			_player = player;			_player.playlist.onBeforeBegin(onBegin);			_player.playlist.onLastSecond(onBeforeFinish);			_loader = _player.createLoader();            coverFlow = new CoverFlow({                imageWidth: 150,                height: _config.height,                width: width,                items: _config.items,                horizontalSpacing: _config.horizontalSpacing,                relfectionSpacing: _config.relfectionSpacing,                showReflection: _config.showReflection,                maskRatio: _config.maskRatio,                mouseOutListener: onMouseOut,                mouseOverListener: onMouseOver,                mouseClickListener: onMouseClick,                pagingListener: onPaging            });            coverFlow.alpha = 0;            addChild(coverFlow);            maximizeBtn = new MaximizeBtn() as Sprite;            _player.addToPanel(maximizeBtn, {right:0, bottom:0, zIndex: 100});            maximizeBtn.visible = false;            createTextField();            _model.dispatchOnLoad();        }				private function playSelectedClip(index:int):void		{			if (_showingClips[index]) {				close();				//coverFlow.visible = false;				_player.close();				_player.play(_showingClips[index]);			}		}				public function onMouseClick(selectedIndex:int):void		{			playSelectedClip(selectedIndex);		}				public function onMouseOut():void		{			_text.htmlText = _pageResults;		}				public function onMouseOver(selectedIndex:int):void		{			_text.htmlText = _showingClips[selectedIndex].customProperties.title;		}				private function isLastItem():Boolean		{			return _player.playlist.currentIndex + 1 >= _player.playlist.length;			}				private function onBeforeFinish(event:ClipEvent):void		{			clear();			coverFlow.clear();			openRelatedClips();			show();		}		protected function populateThumbnails(clips:Array):void		{            _showingClips = [];            _coverFlowData = [];            var currentClip:Clip = _player.currentClip;            log.debug("populateThumbnails() current clip is " + currentClip);			for (var i:int = 0; i < clips.length; i++)			{                log.debug("populateThumbnails() populating thumb for " + clips[i]);                if (Clip(clips[i]).completeUrl != currentClip.completeUrl) {                    _coverFlowData.push(clips[i].customProperties[_config.image]);                    _showingClips.push(clips[i]);                } else {                    log.debug("populateThumbnails() skipping this because it has the same url as the current clip");                }			}			coverFlow.data = _coverFlowData;		}		public function onPaging():void		{			_pageResults = coverFlow.getResults();			_text.htmlText = _pageResults;		}				protected function getRelatedClips(related:*, isFromPluginConfig:Boolean = false):void		{			if (related is Array)			{				log.debug("Creating related videos from config");				_relatedClips = _player.createClips(related);                if (isFromPluginConfig) {                    _defaultRelated = _relatedClips.slice();                }				//_defaultText = "1 - " + _relatedClips.length + " of " + _relatedClips.length;				//_text.htmlText = _defaultText;				populateThumbnails(_relatedClips);			} else if (related is String) {				var loader:ResourceLoaderImpl = new ResourceLoaderImpl(null, _player);				loader.load(related, function(loader:ResourceLoader):void {                    _relatedClips = _player.createClips(JSON.decode(loader.getContent().toString()));                    if (isFromPluginConfig) {                        _defaultRelated = _relatedClips.slice();                    }                    populateThumbnails(_relatedClips);                }, true);				log.debug("Loading related videos from external config " + related);			}		}		private function clear():void		{			_relatedClips = null;			_currentIndex = 0;			}				protected function onBegin(event:ClipEvent):void {			close();			coverFlow.clear();		}				private function openRelatedClips():void		{			if (_player.currentClip.getCustomProperty("related") != null)			{				getRelatedClips(_player.currentClip.getCustomProperty("related"));			} else if (_config.related != null) {                if (_defaultRelated) {                    log.debug("populating thumbnails that were already loaded");                    populateThumbnails(_defaultRelated);                } else {                    log.debug("Loading related clips from default config");                    getRelatedClips(_config.related, true);                }			}		}		public function getDefaultConfig():Object {			return {width: "80%"};		}				[External]		public function open():void		{			if (!_isRelatedVideosOpen) show();		}				[External]        public function show():void        {            screen = _player.pluginRegistry.getPlugin("screen") as DisplayProperties;            oldDisplayProperties = screen;            _player.animationEngine.animate(coverFlow, {alpha:1}, 0.5);            _text.visible = true;            _player.animationEngine.animate(screen.getDisplayObject(), _config.screen, 400, showRelatedVideos);        }				private function showRelatedVideos():void		{			_model.dispatch(PluginEventType.PLUGIN_EVENT, "onShow");			_isRelatedVideosOpen = true;			maximizeBtn.visible = true;						maximizeBtn.x = screen.getDisplayObject().width - maximizeBtn.width;			maximizeBtn.y = screen.getDisplayObject().height - maximizeBtn.height;				maximizeBtn.addEventListener(MouseEvent.CLICK, onMaximize);		}						private function onMaximize(event:MouseEvent):void		{			close();		}				private function closeRelatedVideos():void		{			log.error("closed");			_model.dispatch(PluginEventType.PLUGIN_EVENT, "onClose");			_isRelatedVideosOpen = false;		}				[External]		public function close():void		{			if (_isRelatedVideosOpen) {				log.error("closing");				maximizeBtn.visible = false;				_model.dispatch(PluginEventType.PLUGIN_EVENT, "onBeforeClose");				_player.animationEngine.animate(coverFlow, {alpha:0}, 0.5);				_text.visible = false;				_text.htmlText = "";				_player.animationEngine.animate(oldDisplayProperties.getDisplayObject(), oldDisplayProperties, 400, closeRelatedVideos);			}		}				[External]		public function setItems(items:Array):void		{			_relatedClips = items;		}				[External]		public function click(index:int):void		{			playSelectedClip(index);		}        [External]        public function get outsideLength():Number {            return coverFlow.outsideLength;        }        [External]        public function get coverFlowLength():Number {            return coverFlow.width;        }        [External]        public function get pageLength():Number {            return coverFlow.currentPageWidth;        }        [External]        public function set coverX(value:Number):void {            coverFlow.containerX = value;        }        [External]        public function get mouseRatio():Number {            return coverFlow.mouseRatio;        }        [External]        public function set cameraZ(value:int):void {            coverFlow.cameraZ = value;        }	}}