/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008, 2009 Flowplayer Oy * H.264 support by: Arjen Wagenaar, <h264@code-shop.com> * Copyright (c) 2009 CodeShop B.V. * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.youtube {import org.flowplayer.model.ClipEvent;import org.flowplayer.controller.NetStreamControllingStreamProvider;import org.flowplayer.model.ClipEventType;import org.flowplayer.model.Plugin;import org.flowplayer.model.PluginModel;import org.flowplayer.util.PropertyBinder;import org.flowplayer.view.Flowplayer;import flash.events.NetStatusEvent;import org.flowplayer.model.Clip;import flash.net.NetStream;import flash.net.URLLoader;import flash.net.URLRequest;import flash.net.URLVariables;import flash.display.Loader;import flash.events.Event;import flash.events.IOErrorEvent;	/**     * @author api     */public class YouTubeStreamProvider extends NetStreamControllingStreamProvider implements Plugin {    private var _config:Config;    private var _model:PluginModel;        private var _bufferStart:Number;    private var apiLoader:URLLoader;    private var playerLoader:Loader;    private var youTubePlayer:Object;    private var _player:Flowplayer;    private var _clip:Clip;        /**     * Called by the player to set my config.     */    override public function onConfig(model:PluginModel):void {        _model = model;        _config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;    }    /**     * Called by the player to set the Flowplayer API.     */    override public function onLoad(player:Flowplayer):void {    	        //log.info("onLoad, registering metadata listener");        _model.dispatchOnLoad();    }        private function setupPlayer():void {      playerLoader = new Loader();      playerLoader.addEventListener(Event.INIT, playerInitHandler);      playerLoader.load(new URLRequest(_config.apiPlayerURL));    }        private function setupApiLoader():void {      apiLoader = new URLLoader();      apiLoader.addEventListener(IOErrorEvent.IO_ERROR,                                        apiLoaderErrorHandler);      apiLoader.addEventListener(Event.COMPLETE,                                        apiLoaderCompleteHandler);    }         private function apiLoaderCompleteHandler(event:Event):void {      var atomData:String = apiLoader.data;      var atomXml:XML = new XML(atomData);            log.debug(atomXml);      //var aspectRatios:XMLList = atomXml..*::aspectRatio;      //isWidescreen = aspectRatios.toString() == WIDESCREEN_ASPECT_RATIO;       youTubePlayer.loadVideoById(_clip.url);    }        private function requestApiURL():void {      var request:URLRequest = new URLRequest(_config.gdataApiURL + _clip.url);      var urlVariables:URLVariables = new URLVariables();      urlVariables.v = _config.gdataApiVersion;      urlVariables.format = _config.gdataApiFormat;      request.data = urlVariables;      try {        apiLoader.load(request);      } catch (error:SecurityError) {        log.error("A SecurityError occurred while loading", request.url);      }    }        private function apiLoaderErrorHandler(event:IOErrorEvent):void {      log.error("Error making YouTube API request:", event);    }        private function playerInitHandler(event:Event):void {    	      _player.addToPanel(playerLoader,{width: _player.screen.widthPx, height: _player.screen.heightPx });      playerLoader.content.addEventListener("onReady", onPlayerReady);      playerLoader.content.addEventListener("onError", onPlayerError);      playerLoader.content.addEventListener("onStateChange",                                            onPlayerStateChange);      playerLoader.content.addEventListener("onPlaybackQualityChange",                                            onVideoPlaybackQualityChange);                                                                                            }        private function onPlayerReady(event:Event):void {      youTubePlayer = playerLoader.content;            requestApiURL();    }    private function onPlayerError(event:Event):void {      trace("Player error:", Object(event).data);    }    private function onPlayerStateChange(event:Event):void {      trace("State is", Object(event).data);      switch (Object(event).data) {        case YouTubePlayerState.ENDED:          break;        case YouTubePlayerState.PLAYING:          break;        case YouTubePlayerState.PAUSED:                    break;		case YouTubePlayerState.BUFFERING:				break;        case YouTubePlayerState.CUED:          //resizePlayer("medium");          break;      }    }    private function onVideoPlaybackQualityChange(event:Event):void {      //trace("Current video quality:", Object(event).data);      //resizePlayer(Object(event).data);    }    override protected function getClipUrl(clip:Clip):String {        return clip.completeUrl;    }        override protected function onClipUrlResolved(clip:Clip):void {    	dispatchEvent(new ClipEvent(ClipEventType.CONNECT));    }        override  protected function connect(clip:Clip, ... rest):void {    	//resolveClipUrl(clip, onClipUrlResolved);    }    override protected function doLoad(event:ClipEvent, netStream:NetStream, clip:Clip):void {        log.info("doLoad");                _clip = clip;        setupPlayer();      	setupApiLoader();      	      	      	/*        _bufferStart = clip.start;        _startSeekDone = false;        if (! _seekDataStore || isNewFile(clip)) {             _seekDataStore = new DefaultSeekDataStore();        }        _seekDataStore.reset();        super.doLoad(event, netStream, clip);*/    }/*    private function isNewFile(clip:Clip):Boolean {        return clip.url != _fileWithKeyframeInfo;    }*/		override protected function doStop(event:ClipEvent, netStream:NetStream, closeStreamAndConnection:Boolean = false):void {		youTubePlayer.stopVideo();	}	    override protected function doSeek(event:ClipEvent, netStream:NetStream, seconds:Number):void {        var target:Number = clip.start + seconds;    	youTubePlayer.seekTo(target, true);    }        override protected function doPause(netStream:NetStream, event:ClipEvent = null):void {    	youTubePlayer.pauseVideo();      }        override protected function doResume(netStream:NetStream, event:ClipEvent):void {    	youTubePlayer.playVideo();    }            override protected function doSwitchStream(event:ClipEvent, netStream:NetStream, clip:Clip, netStreamPlayOptions:Object = null):void {    	    	var currentTime:Number = youTubePlayer.getCurrentTime();    	    		    youTubePlayer.loadVideoById(clip.url);	    youTubePlayer.seekTo(currentTime, true);    	    }    override public function get bufferStart():Number {        if (! clip) return 0;        return _bufferStart - clip.start;    }    override public function get bufferEnd():Number {        if (! clip) return 0;        if (!youTubePlayer) return 0;        return bufferStart + youTubePlayer.getBytesLoaded()/youTubePlayer.getBytesTotal() * (youTubePlayer.getDuration() - bufferStart);    }    override protected function getCurrentPlayheadTime(netStream:NetStream):Number {    	if (!youTubePlayer) return 0;        return youTubePlayer.getCurrentTime();    }    override public function get allowRandomSeek():Boolean {       return true;    }       override protected function canDispatchBegin():Boolean {        return true;    }    override protected function onNetStatus(event:NetStatusEvent):void {            }    public function getDefaultConfig():Object {        return null;    }        override public function get type():String {		return "youtube";		}}}