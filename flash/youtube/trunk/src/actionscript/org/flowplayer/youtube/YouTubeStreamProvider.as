/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com>, Anssi Piirainen Flowplayer Oy * Copyright (c) 2009 Electroteque Multimedia, Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.youtube {import org.flowplayer.model.DisplayProperties;import org.flowplayer.model.ClipEvent;import org.flowplayer.model.PlayerEvent;import org.flowplayer.controller.StreamProvider;import org.flowplayer.util.Log;import org.flowplayer.model.ClipEventType;import org.flowplayer.model.Plugin;import org.flowplayer.model.PluginModel;import org.flowplayer.model.ProviderModel;import org.flowplayer.util.PropertyBinder;import org.flowplayer.view.Flowplayer;import flash.events.NetStatusEvent;import org.flowplayer.model.Clip;import flash.net.NetStream;import flash.net.NetConnection;import flash.display.DisplayObject;import flash.net.URLLoader;import flash.net.URLRequest;import flash.net.URLVariables;import flash.display.Loader;import flash.events.Event;import flash.events.IOErrorEvent;import org.flowplayer.model.ClipError;import org.flowplayer.controller.TimeProvider;import org.flowplayer.controller.VolumeController;import org.flowplayer.model.Playlist;import org.flowplayer.controller.ClipURLResolver;import org.flowplayer.controller.CompositeClipUrlResolver;	/**	 * @author danielr     */public class YouTubeStreamProvider implements Plugin,ClipURLResolver,StreamProvider {	    private var _config:Config;	protected var log:Log = new Log(this);	private var _startedClip:Clip;	private var _playlist:Playlist;	private var _pauseAfterStart:Boolean;	private var _volumeController:VolumeController;	private var _seekTarget:Number;	private var _model:PluginModel;	private var _player:Flowplayer;    private var _bufferStart:Number;        private var _apiLoader:URLLoader;    private var _playerLoader:Loader;    private var _youTubePlayer:Object;    private var _isWidescreen:Boolean = false;	private var _defaultClipUrlResolver:ClipURLResolver;   	private var _clipUrlResolver:ClipURLResolver;   	private var _failureListener:Function;        // state variables	private var _silentSeek:Boolean;	private var _paused:Boolean;	private var _stopping:Boolean;	private var _started:Boolean;    private var _timeProvider:TimeProvider;    private var _seeking:Boolean;            /**     * Called by the player to set my config.     */    public function onConfig(model:PluginModel):void {        _model = model;        _config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;    }        public function set model(model:ProviderModel):void {		_model = model;		onConfig(model);	}		public function set player(player:Flowplayer):void {		_player = player;		onLoad(player);	}		protected function get youTubePlayer():Object {		return _youTubePlayer;	}		public function onLoad(player:Flowplayer):void { 				_player = player;			player.onVolume(function(event:PlayerEvent):void {			if (!youTubePlayer) return;			youTubePlayer.setVolume(Number(event.info));		});				player.onMute(function(event:PlayerEvent):void {			if (!youTubePlayer) return;			youTubePlayer.mute();		});				player.onUnmute(function(event:PlayerEvent):void {			if (!youTubePlayer) return;			youTubePlayer.unMute();		});						_model.dispatchOnLoad();	}	    /**     * Called by the player to set the Flowplayer API.     */    private function setupPlayer():void {      _playerLoader = new Loader();      _playerLoader.contentLoaderInfo.addEventListener(Event.INIT, playerInitHandler);      _playerLoader.load(new URLRequest(_config.apiPlayerURL));          }        private function setupApiLoader():void {      _apiLoader = new URLLoader();      _apiLoader.addEventListener(IOErrorEvent.IO_ERROR,                                        _apiLoaderErrorHandler);      _apiLoader.addEventListener(Event.COMPLETE,                                        _apiLoaderCompleteHandler);    }         private function _apiLoaderCompleteHandler(event:Event):void {      var atomData:String = _apiLoader.data;      var atomXml:XML = new XML(atomData);            log.debug(atomXml);      var aspectRatios:XMLList = atomXml..*::aspectRatio;      _isWidescreen = aspectRatios.toString() == "widescreen";			  doLoad();      }        private function doLoad():void    {    	_bufferStart = 0;    	//if (_pauseAfterStart) {    	//	youTubePlayer.cueVideoById(clip.url, clip.start, "large");    	//} else {    		youTubePlayer.loadVideoById(clip.url, clip.start, _config.defaultQuality);    	//}    }        private function resizePlayer(qualityLevel:String):void {       var width:Number = Number(_config.videoFormats[qualityLevel].width);       var height:Number = Number(_config.videoFormats[qualityLevel].height);		      if (_isWidescreen) {        // Widescreen videos (usually) fit into a 16:9 player.        height = width * 9 / 16;      } else {        // Non-widescreen videos fit into a 4:3 player.        height = width * 3 / 4;      }      	  var screen:DisplayProperties  = _player.pluginRegistry.getPlugin("screen") as DisplayProperties;  	  youTubePlayer.setSize(screen.getDisplayObject().width,screen.getDisplayObject().height);    }            private function requestApiURL():void {      var request:URLRequest = new URLRequest(_config.gdataApiURL + clip.url);      var urlVariables:URLVariables = new URLVariables();      urlVariables.v = _config.gdataApiVersion;      urlVariables.format = _config.gdataApiFormat;      request.data = urlVariables;      try {        _apiLoader.load(request);      } catch (error:SecurityError) {      	log.error("A SecurityError occurred while loading", request.url);      	dispatchError(ClipError.STREAM_LOAD_FAILED, "A SecurityError occurred while loading: " + request.url + " "  + error.message);	           }    }        private function _apiLoaderErrorHandler(event:IOErrorEvent):void {      dispatchError(ClipError.STREAM_LOAD_FAILED, "Error making YouTube API request: " + event.text);	    }        private function playerInitHandler(event:Event):void {      _playerLoader.content.addEventListener("onReady", onPlayerReady);      _playerLoader.content.addEventListener("onError", onPlayerError);      _playerLoader.content.addEventListener("onStateChange",                                            onPlayerStateChange);      _playerLoader.content.addEventListener("onPlaybackQualityChange",                                            onVideoPlaybackQualityChange);                                }        private function onPlayerReady(event:Event):void {      _youTubePlayer = _playerLoader.content;            youTubePlayer.setVolume(_volumeController.volume);            if (! _paused && canDispatchBegin()) {        	log.debug("dispatching onBegin");            clip.dispatchEvent(new ClipEvent(ClipEventType.BEGIN, _pauseAfterStart));      }      requestApiURL();    }    private function onPlayerError(event:Event):void {    	log.error("Error is", Object(event).data);    	switch (Object(event).data) {    		case YouTubePlayerError.STREAM_NOT_FOUND:    			if (canDispatchStreamNotFound()) {                    dispatchError(ClipError.STREAM_NOT_FOUND, "Requested video cannot be found or has been deleted");                }    		break;    		case YouTubePlayerError.EMBED_NOT_ALLOWED:			case YouTubePlayerError.EMBED_NOT_ALLOWED2:    			dispatchError(ClipError.STREAM_LOAD_FAILED, "Video failed to load due to embedding disabled");	    		break;    	}    }    private function onPlayerStateChange(event:Event):void {      log.debug("State is", Object(event).data);      switch (Object(event).data) {        case YouTubePlayerState.ENDED:				dispatchEvent(new ClipEvent(ClipEventType.STOP));        break;        case YouTubePlayerState.PLAYING:        	 dispatchEvent(new ClipEvent(ClipEventType.BUFFER_FULL));			 if (!clip.startDispatched) sendMetaData();        	//dispatchEvent(new ClipEvent(ClipEventType.START));        break;        case YouTubePlayerState.PAUSED:          	dispatchEvent(new ClipEvent(ClipEventType.PAUSE));		break;		case YouTubePlayerState.BUFFERING:			dispatchEvent(new ClipEvent(ClipEventType.BUFFER_EMPTY));		break;        case YouTubePlayerState.CUED:		  sendMetaData();		          break;      }    }    private function onVideoPlaybackQualityChange(event:Event):void {      //trace("Current video quality:", Object(event).data);      //resizePlayer(Object(event).data);    }        private function sendMetaData():void {			log.info("sendMetaData, current clip " + clip);            //log.debug("sendMetaData, data for clip " + clip + ":");            var quality:String = youTubePlayer.getPlaybackQuality();            //log.error("Player Quality: " + quality);                       /* var metaData:Object = new Object();            for (var key:String in infoObject) {                log.debug(key + ": " + infoObject[key]);                metaData[key] = infoObject[key];            }*/                                    var qualityLevels:Array = youTubePlayer.getAvailableQualityLevels();                                    for (var key:String in qualityLevels) {                //log.error(key + ": " + qualityLevels[key]);                var level:String = qualityLevels[key];								if (!clip.getCustomProperty("bitrates")) clip.setCustomProperty("bitrates", []);								if (_config.videoFormats[level]) {					log.debug("Setting bitrate for clip with level " + level);					clip.customProperties["bitrates"].push(						{							"url":clip.url, 						 	"bitrate": Number(_config.videoFormats[level].bitrate),						 	"width": Number(_config.videoFormats[level].width), 						 	"height": Number(_config.videoFormats[level].height)						 }					);				}				            }                        var playbackQualityLevel:String = youTubePlayer.getPlaybackQuality();            var width:Number = Number(_config.videoFormats[playbackQualityLevel].width);            var height:Number = Number(_config.videoFormats[playbackQualityLevel].height);            var metaData:Object = {width: width, height: height, duration: youTubePlayer.getDuration(), bytesTotal: youTubePlayer.getVideoBytesTotal()};            clip.metaData = metaData;			resizePlayer(playbackQualityLevel);                       // clip.dispatch(ClipEventType.METADATA);           dispatchEvent(new ClipEvent(ClipEventType.METADATA));            	}			private function onMetaData(event:ClipEvent):void {			log.info("in YouTubeStremProvider.onMetaData: " + event.target);											if (! clip.startDispatched && !_pauseAfterStart) {                clip.dispatch(ClipEventType.START, _pauseAfterStart);                clip.startDispatched = true;            } else {			//if (_pauseAfterStart) {				log.info("seeking to frame zero");				seek(null, 0);				pause(null);				//dispatchEvent(new ClipEvent(ClipEventType.PAUSE)); 				_pauseAfterStart = false;			}	}	public function load(event:ClipEvent, clip:Clip, pauseAfterStart:Boolean = false):void {        log.info("doLoad");        _stopping = false;        clip.onMetaData(onMetaData);        clip.startDispatched = false;        _pauseAfterStart = pauseAfterStart;              	resolveClipUrl(clip, onClipUrlResolved);    }        protected final function resolveClipUrl(clip:Clip, successListener:Function):void {			clipURLResolver.resolve(this, clip, successListener);	}		protected function onClipUrlResolved(clip:Clip):void {    	setupPlayer();      	setupApiLoader();    }        private function get clipURLResolver():ClipURLResolver {            log.debug("get clipURLResolver,  clip.urlResolver = " + clip.urlResolvers + ", _clipUrlResolver = " + _defaultClipUrlResolver);            if (! clip || (clip.urlResolvers && clip.urlResolvers[0] == null)) {                clip.urlResolverObjects = [_defaultClipUrlResolver];                return _defaultClipUrlResolver;            }            // defined in clip?            if (clip.urlResolvers) {                _clipUrlResolver = CompositeClipUrlResolver.createResolver(clip.urlResolvers, _player.pluginRegistry);            } else {                // get all resolvers from repository                var configured:Array = _player.pluginRegistry.getUrlResolvers();                if (configured && configured.length > 0) {                    log.debug("using configured URL resolvers", configured);                    _clipUrlResolver = CompositeClipUrlResolver.createResolver(configured, _player.pluginRegistry);                }            }            if (! _clipUrlResolver) {                _clipUrlResolver = _defaultClipUrlResolver;            }            _clipUrlResolver.onFailure = function(message:String = null):void {                log.error("clip URL resolving failed: " + message);                clip.dispatchError(ClipError.STREAM_LOAD_FAILED, "failed to resolve clip url" + (message ? ": " + message : ""));            };            clip.urlResolverObjects = _clipUrlResolver is CompositeClipUrlResolver ? CompositeClipUrlResolver(_clipUrlResolver).resolvers : [_clipUrlResolver];            return _clipUrlResolver;        }            protected final function get pauseAfterStart():Boolean {		return _pauseAfterStart;	}			protected final function set pauseAfterStart(value:Boolean):void {		_pauseAfterStart = value;	}   	public function stop(event:ClipEvent, closeStream:Boolean = false):void {		_stopping = true;		youTubePlayer.stopVideo();		//dispatchEvent(event);	}	    public function seek(event:ClipEvent, seconds:Number):void {    	silentSeek = event == null;		log.debug("seekTo " + seconds);		_seekTarget = seconds;		doSeek(event, seconds);	          }        protected function doSeek(event:ClipEvent, seconds:Number):void {    	var target:Number = clip.start + seconds;    	youTubePlayer.seekTo(target, true);    	_seeking = true;    	_bufferStart = seconds;    	dispatchEvent(event);    }        public function pause(event:ClipEvent):void {    	_stopping = false;    	youTubePlayer.pauseVideo();    	//dispatchEvent(event);      }        public function resume(event:ClipEvent):void {    	_stopping = false;    	youTubePlayer.playVideo();    	dispatchEvent(event);    }            public function switchStream(event:ClipEvent, clip:Clip, netStreamPlayOptions:Object = null):void {    	    	var currentTime:Number = youTubePlayer.getCurrentTime();	    youTubePlayer.loadVideoById(clip.url,currentTime);	    dispatchEvent(event);    }        protected final function dispatchEvent(event:ClipEvent):void {		if (! event) return;		log.debug("dispatching " + event + " on clip " + clip);		clip.dispatchEvent(event);	}		private function dispatchError(error:ClipError, info:String):void {		clip.dispatchError(error, info);	}		public function getVideo(clip:Clip):DisplayObject {		return _playerLoader;	}		public function attachStream(video:DisplayObject):void {			}		public function get fileSize():Number {		if (!youTubePlayer) return 0;		return youTubePlayer.getVideoBytesTotal();	}		public function get time():Number {		if (!youTubePlayer) return 0;		return getCurrentPlayheadTime();	}		protected function getCurrentPlayheadTime():Number {        return youTubePlayer.getCurrentTime();	}		protected final function get clip():Clip {		return _playlist.current;	}		public function get bufferStart():Number {        if (! clip) return 0;        return _bufferStart - clip.start;    }    public function get bufferEnd():Number {        if (! clip) return 0;        if (!youTubePlayer) return 0;        return bufferStart + youTubePlayer.getVideoBytesLoaded()/youTubePlayer.getVideoBytesTotal() * (clip.duration - bufferStart);    }        public function set volumeController(controller:VolumeController):void {    	_volumeController = controller;    }        public function stopBuffering():void {    	    }        public function get stopping():Boolean {    	return _stopping;    }        public function set playlist(playlist:Playlist):void {    	_playlist = playlist;    }		public function get playlist():Playlist {		return _playlist;	}		public function addConnectionCallback(name:String, listener:Function):void {			}		public function addStreamCallback(name:String, listener:Function):void {			}		public function get netStream():NetStream {		return null;	}		public function get netConnection():NetConnection {		return null;	}		public function set timeProvider(timeProvider:TimeProvider):void {		_timeProvider = timeProvider;	}		protected final function get paused():Boolean {		return _paused;	}		protected final function get seeking():Boolean {    	return _seeking;    }        protected final function set silentSeek(value:Boolean):void {		_silentSeek = value;		log.info("silent mode was set to " + _silentSeek);	}			protected final function get silentSeek():Boolean {		return _silentSeek;	}    protected final function set seeking(value:Boolean):void {    	_seeking = value;    }    public function get allowRandomSeek():Boolean {       return true;    }        protected function canDispatchBegin():Boolean {		return true;	}   	   	protected function canDispatchStreamNotFound():Boolean {		return true;	}		    public function getDefaultConfig():Object {        return null;    }        public function get type():String {		return "youtube";		}		public function handeNetStatusEvent(event:NetStatusEvent):Boolean {    	return true;    }            public function set onFailure(listener:Function):void {		_failureListener = listener;    }	public function resolve(provider:StreamProvider, clip:Clip, successListener:Function):void {		var url:String = clip.url.split(":")[1];		clip.setResolvedUrl(this, url);			if (successListener != null) {			successListener(clip);		}	}  }}