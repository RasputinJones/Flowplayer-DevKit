/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com>, Anssi Piirainen Flowplayer Oy * Copyright (c) 2009 Electroteque Multimedia, Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.youtube {import org.flowplayer.model.DisplayProperties;import org.flowplayer.model.ClipEvent;import org.flowplayer.model.PlayerEvent;import org.flowplayer.controller.StreamProvider;import org.flowplayer.util.Log;import org.flowplayer.model.ClipEventType;import org.flowplayer.model.Plugin;import org.flowplayer.model.PluginModel;import org.flowplayer.model.ProviderModel;import org.flowplayer.util.PropertyBinder;import org.flowplayer.view.Flowplayer;import flash.events.NetStatusEvent;import org.flowplayer.model.Clip;import flash.net.NetStream;import flash.net.NetConnection;import flash.display.DisplayObject;import flash.net.URLLoader;import flash.net.URLRequest;import flash.net.URLVariables;import flash.display.Loader;import flash.events.Event;import flash.events.IOErrorEvent;import org.flowplayer.model.ClipError;import org.flowplayer.controller.TimeProvider;import org.flowplayer.controller.VolumeController;import org.flowplayer.model.Playlist;import org.flowplayer.model.PluginEventType;import org.flowplayer.controller.ClipURLResolver;import org.flowplayer.controller.CompositeClipUrlResolver;import org.flowplayer.youtube.model.Gdata;	/**	 * @author danielr     */public class YouTubeStreamProvider implements Plugin,ClipURLResolver,StreamProvider {	    private var _config:Config;	protected var log:Log = new Log(this);	private var _startedClip:Clip;	private var _playlist:Playlist;	private var _pauseAfterStart:Boolean;	private var _volumeController:VolumeController;	private var _seekTarget:Number;	private var _model:PluginModel;	private var _player:Flowplayer;    private var _bufferStart:Number;        private var _apiLoader:URLLoader;    private var _playerLoader:Loader;    private var _youTubePlayer:Object;    private var _isWidescreen:Boolean = false;	private var _defaultClipUrlResolver:ClipURLResolver;   	private var _clipUrlResolver:ClipURLResolver;   	private var _failureListener:Function;        // state variables	private var _silentSeek:Boolean;	private var _paused:Boolean;	private var _stopping:Boolean;	private var _started:Boolean;    private var _timeProvider:TimeProvider;    private var _seeking:Boolean;        private var _screen:DisplayProperties;    private var _oldscreen:DisplayProperties;            private var _successListener:Function;    private var _resolved:Boolean = false;    private var _gData:Gdata;        private var atom:Namespace = new Namespace("http://www.w3.org/2005/Atom");   	private var media:Namespace = new Namespace("http://search.yahoo.com/mrss/");    private var gd:Namespace = new Namespace("http://schemas.google.com/g/2005");    private var yt:Namespace = new Namespace("http://gdata.youtube.com/schemas/2007");        /**     * Called by the player to set my config.     */    public function onConfig(model:PluginModel):void {        _model = model;        _config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;    }        public function set model(model:ProviderModel):void {		_model = model;		onConfig(model);	}		public function set player(player:Flowplayer):void {		_player = player;		onLoad(player);	}		protected function get youTubePlayer():Object {		return _youTubePlayer;	}		public function onLoad(player:Flowplayer):void { 				_player = player;				_screen = _player.pluginRegistry.getPlugin("screen") as DisplayProperties;  	  	_screen.getDisplayObject().addEventListener(Event.RESIZE, onScreenResize);			player.onVolume(function(event:PlayerEvent):void {			if (!youTubePlayer) return;			youTubePlayer.setVolume(Number(event.info));		});				player.onMute(function(event:PlayerEvent):void {			if (!youTubePlayer) return;			youTubePlayer.mute();		});				player.onUnmute(function(event:PlayerEvent):void {			if (!youTubePlayer) return;			youTubePlayer.unMute();		});						_model.dispatchOnLoad();	}	    /**     * Called by the player to set the Flowplayer API.     */    private function setupPlayer():void {      _playerLoader = new Loader();      _playerLoader.contentLoaderInfo.addEventListener(Event.INIT, playerInitHandler);      _playerLoader.load(new URLRequest(_config.apiPlayerURL));          }        private function setupApiLoader():void {      _apiLoader = new URLLoader();      _apiLoader.addEventListener(IOErrorEvent.IO_ERROR,                                        _apiLoaderErrorHandler);      _apiLoader.addEventListener(Event.COMPLETE,                                        _apiLoaderCompleteHandler);    }         private function _apiLoaderCompleteHandler(event:Event):void {     	default xml namespace = atom;     	var atomData:String = _apiLoader.data;      	var atomXml:XML = new XML(atomData);      	var aspectRatios:XMLList = atomXml..*::aspectRatio;      	_isWidescreen = aspectRatios.toString() == "widescreen";				parseFeedData(atomXml);	  	 	  	    }        private function parseFeedData(atomXml:XML):void {    	_gData = new Gdata();     	_gData.tags = String(atomXml.media::group.media::keywords).split(",");		_gData.category = String(atomXml.media::group.media::category.@label);		_gData.title = String(atomXml.title);		_gData.content = String(atomXml.media::group.media::description);		_gData.author = {name: String(atomXml.author.name), uri: String(atomXml.author.uri)};					var thumbnails:Array = buildThumbnailsList(XMLList(atomXml.media::group.media::thumbnail));		_gData.defaultThumbnail = String(thumbnails[thumbnails.length - 1].url);		_gData.thumbnails = thumbnails;				_gData.statistics = {favoriteCount: Number(atomXml.yt::statistics.@favoriteCount), viewCount: Number(atomXml.yt::statistics.@viewCount)};		_gData.duration = Number(atomXml.media::group.yt::duration.@seconds);		_gData.bitrates = clip.getCustomProperty("bitrates") as Array;		var links:XMLList = XMLList(atomXml.link);				getRelatedVideos(links[2].@href);		    }        private function getRelatedVideos(url:String):void {    	var relatedLoader:URLLoader = new URLLoader();      	relatedLoader.addEventListener(Event.COMPLETE, function(event:Event):void {			var relatedDataXML:XML = XML(relatedLoader.data);			var entries:XMLList = XMLList(relatedDataXML.entry);						if (!clip.getCustomProperty("related")) {				clip.setCustomProperty("related", []);							for each (var entry:XML in entries) {					var id:String = String(entry.id).substring(String(entry.id).lastIndexOf(":") + 1, String(entry.id).length);					var author:Object = {name: String(entry.author.name), uri: String(entry.author.uri)};										var tags:Array = String(entry.media::group.media::keywords).split(",");										var thumbnails:Array = buildThumbnailsList(XMLList(entry.media::group.media::thumbnail));					var defaultThumbnail:String = (thumbnails.length > 0 ? thumbnails[thumbnails.length - 1].url : "");								var ratings:Object = {average: Number(entry.gd::rating.@average), max: Number(entry.gd::rating.@max), min: Number(entry.gd::rating.@min), numRaters: Number(entry.gd::rating.@numRaters)};					var statistics:Object = {favoriteCount: Number(entry.yt::statistics.@favoriteCount), viewCount: Number(entry.yt::statistics.@viewCount)};										clip.customProperties["related"].push({url: "api:" + id, title: String(entry.title), content: String(entry.media::group.media::description), author: author, tags:tags, category: String(entry.media::group.media::category.@label), defaultThumbnail: defaultThumbnail, thumbnails: thumbnails, duration: Number(entry.media::group.yt::duration.@seconds), ratings: ratings, statistics: statistics});									}							_gData.relatedVideos = clip.customProperties["related"];			}						_model.dispatch(PluginEventType.PLUGIN_EVENT, "onApiData", _gData);						//we have got the related video data start playing the video			doLoad(); 				});      	relatedLoader.load(new URLRequest(url));	    }        private function buildThumbnailsList(thumbnailList:XMLList):Array {    	var thumbnails:Array = [];		for each (var thumbnail:Object in thumbnailList) {						thumbnails.push({url: String(thumbnail.@url), height: Number(thumbnail.@height), width: Number(thumbnail.@width), time: String(thumbnail.@time)});		}				return thumbnails;    }        private function doLoad():void    {    	_playerLoader.content.removeEventListener("onStateChange",                                            onInitPlayerStateChange);        _playerLoader.content.addEventListener("onStateChange",                                            onPlayerStateChange);    	_bufferStart = 0;        	youTubePlayer.loadVideoById(clip.url, clip.start, _config.defaultQuality);    	    	if (! _paused && canDispatchBegin()) {        	log.debug("dispatching onBegin");            clip.dispatchEvent(new ClipEvent(ClipEventType.BEGIN, _pauseAfterStart));      	}    }       private function requestApiURL():void {    	var request:URLRequest = new URLRequest(_config.gdataApiURL + clip.url);      	var urlVariables:URLVariables = new URLVariables();      	urlVariables.v = _config.gdataApiVersion;      	urlVariables.format = _config.gdataApiFormat;      	request.data = urlVariables;      	try {        	_apiLoader.load(request);      	} catch (error:SecurityError) {      		log.error("A SecurityError occurred while loading", request.url);      		dispatchError(ClipError.STREAM_LOAD_FAILED, "A SecurityError occurred while loading: " + request.url + " "  + error.message);	      	}    }        private function _apiLoaderErrorHandler(event:IOErrorEvent):void {    	dispatchError(ClipError.STREAM_LOAD_FAILED, "Error making YouTube API request: " + event.text);	    }        private function playerInitHandler(event:Event):void {      	_playerLoader.content.addEventListener("onReady", onPlayerReady);		_playerLoader.content.addEventListener("onError", onPlayerError);      	_playerLoader.content.addEventListener("onPlaybackQualityChange",                                            onVideoPlaybackQualityChange);                                }        private function onPlayerReady(event:Event):void {      	_youTubePlayer = _playerLoader.content;      	      	//setup initial player state event to obtain quality levels      	_playerLoader.content.addEventListener("onStateChange",                                            onInitPlayerStateChange);                                                  	youTubePlayer.setVolume(_volumeController.volume);				//we are trying to initially load the video to obtain quality levels            	youTubePlayer.loadVideoById(clip.url);    }    private function onPlayerError(event:Event):void {    	log.error("Error is", Object(event).data);    	switch (Object(event).data) {    		case YouTubePlayerError.STREAM_NOT_FOUND:    			if (canDispatchStreamNotFound()) {                    dispatchError(ClipError.STREAM_NOT_FOUND, "Requested video cannot be found or has been deleted");                }    		break;    		case YouTubePlayerError.EMBED_NOT_ALLOWED:			case YouTubePlayerError.EMBED_NOT_ALLOWED2:    			dispatchError(ClipError.STREAM_LOAD_FAILED, "Video failed to load due to embedding disabled");	    		break;    	}    }		private function onInitPlayerStateChange(event:Event):void {		switch (Object(event).data) {			case YouTubePlayerState.PLAYING:        	 	//capture quality levels into a bitrates list, stop the video and trigger clip resolving success.        	 	buildBitrateList();        	 	youTubePlayer.stopVideo();        	 		        	 	if (_successListener != null) {					_successListener(clip);				}        	break;		}	}	    private function onPlayerStateChange(event:Event):void {   		log.debug("State is", Object(event).data);      	switch (Object(event).data) {        	case YouTubePlayerState.ENDED:				dispatchEvent(new ClipEvent(ClipEventType.STOP));        	break;        	case YouTubePlayerState.PLAYING:        	 	dispatchEvent(new ClipEvent(ClipEventType.BUFFER_FULL));        	 	        	 	if (!clip.startDispatched) sendMetaData();        	 	        		//dispatchEvent(new ClipEvent(ClipEventType.START));        	break;        	case YouTubePlayerState.PAUSED:          		dispatchEvent(new ClipEvent(ClipEventType.PAUSE));			break;				case YouTubePlayerState.BUFFERING:				dispatchEvent(new ClipEvent(ClipEventType.BUFFER_EMPTY));			break;        	case YouTubePlayerState.CUED:        	break;      	}    }    private function onVideoPlaybackQualityChange(event:Event):void {      //trace("Current video quality:", Object(event).data);      //resizePlayer(Object(event).data);    }        private function onScreenResize(event:Event):void {    	    }        private function resizePlayer(qualityLevel:String):void {    	var width:Number = Number(_config.videoFormats[qualityLevel].width);       	var height:Number = Number(_config.videoFormats[qualityLevel].height);		      	if (_isWidescreen) {        	// Widescreen videos (usually) fit into a 16:9 player.       	 	height = width * 9 / 16;     	} else {        	// Non-widescreen videos fit into a 4:3 player.        	height = width * 3 / 4;      	}      	  		  	youTubePlayer.setSize(_screen.getDisplayObject().width,_screen.getDisplayObject().height);    }        private function buildBitrateList():void {    	var qualityLevels:Array = youTubePlayer.getAvailableQualityLevels();    	    	//log.error(qualityLevels.length.toString());    	for (var key:String in qualityLevels) {        	//log.error(key + ": " + qualityLevels[key]);            var level:String = qualityLevels[key];							if (!clip.getCustomProperty("bitrates")) clip.setCustomProperty("bitrates", []);							if (_config.videoFormats[level]) {				log.debug("Setting bitrate for clip with level " + level);				clip.customProperties["bitrates"].push(					{						"url": "api:" + clip.url, 						"bitrate": Number(_config.videoFormats[level].bitrate),						"width": Number(_config.videoFormats[level].width), 						"height": Number(_config.videoFormats[level].height),						"format": level,						"type": _config.videoFormats[level].type,						"label": _config.videoFormats[level].label					}					);				}            }    }    private function sendMetaData():void {		log.info("sendMetaData, current clip " + clip);                var playbackQualityLevel:String = youTubePlayer.getPlaybackQuality();        var width:Number = Number(_config.videoFormats[playbackQualityLevel].width);        var height:Number = Number(_config.videoFormats[playbackQualityLevel].height);        var metaData:Object = {width: width, height: height, duration: youTubePlayer.getDuration(), bytesTotal: youTubePlayer.getVideoBytesTotal()};        clip.metaData = metaData;		resizePlayer(playbackQualityLevel);                          dispatchEvent(new ClipEvent(ClipEventType.METADATA));    	}			private function onMetaData(event:ClipEvent):void {		log.info("in YouTubeStremProvider.onMetaData: " + event.target);		if (! clip.startDispatched && !_pauseAfterStart) {        	clip.dispatch(ClipEventType.START, _pauseAfterStart);            clip.startDispatched = true;        } else {			log.info("seeking to frame zero");			seek(null, 0);			pause(null);			_pauseAfterStart = false;		}	}	public function load(event:ClipEvent, clip:Clip, pauseAfterStart:Boolean = false):void {        log.info("doLoad");        _stopping = false;        clip.onMetaData(onMetaData);        clip.startDispatched = false;        _pauseAfterStart = pauseAfterStart;              	resolveClipUrl(clip, onClipUrlResolved);    }        protected final function resolveClipUrl(clip:Clip, successListener:Function):void {			clipURLResolver.resolve(this, clip, successListener);	}		protected function onClipUrlResolved(clip:Clip):void {      	//obtain video information from the gdata xml feed for the video and then play the video.       	if (_config.enableGdata) {      		requestApiURL();      	      	} else {      		doLoad();      	}    }        private function get clipURLResolver():ClipURLResolver {            log.debug("get clipURLResolver,  clip.urlResolver = " + clip.urlResolvers + ", _clipUrlResolver = " + _defaultClipUrlResolver);            if (! clip || (clip.urlResolvers && clip.urlResolvers[0] == null)) {                clip.urlResolverObjects = [_defaultClipUrlResolver];                return _defaultClipUrlResolver;            }            // defined in clip?            if (clip.urlResolvers) {                _clipUrlResolver = CompositeClipUrlResolver.createResolver(clip.urlResolvers, _player.pluginRegistry);            } else {                // get all resolvers from repository                var configured:Array = _player.pluginRegistry.getUrlResolvers();                if (configured && configured.length > 0) {                    log.debug("using configured URL resolvers", configured);                    _clipUrlResolver = CompositeClipUrlResolver.createResolver(configured, _player.pluginRegistry);                }            }            if (! _clipUrlResolver) {                _clipUrlResolver = _defaultClipUrlResolver;            }            _clipUrlResolver.onFailure = function(message:String = null):void {                log.error("clip URL resolving failed: " + message);                clip.dispatchError(ClipError.STREAM_LOAD_FAILED, "failed to resolve clip url" + (message ? ": " + message : ""));            };            clip.urlResolverObjects = _clipUrlResolver is CompositeClipUrlResolver ? CompositeClipUrlResolver(_clipUrlResolver).resolvers : [_clipUrlResolver];            return _clipUrlResolver;        }            protected final function get pauseAfterStart():Boolean {		return _pauseAfterStart;	}			protected final function set pauseAfterStart(value:Boolean):void {		_pauseAfterStart = value;	}   	public function stop(event:ClipEvent, closeStream:Boolean = false):void {		_stopping = true;		youTubePlayer.stopVideo();	}	    public function seek(event:ClipEvent, seconds:Number):void {    	silentSeek = event == null;		log.debug("seekTo " + seconds);		_seekTarget = seconds;		doSeek(event, seconds);	          }        protected function doSeek(event:ClipEvent, seconds:Number):void {    	var target:Number = clip.start + seconds;    	youTubePlayer.seekTo(target, true);    	_seeking = true;    	_bufferStart = seconds;    	dispatchEvent(event);    }        public function pause(event:ClipEvent):void {    	_stopping = false;    	youTubePlayer.pauseVideo();      }        public function resume(event:ClipEvent):void {    	_stopping = false;    	youTubePlayer.playVideo();    	dispatchEvent(event);    }            public function switchStream(event:ClipEvent, clip:Clip, netStreamPlayOptions:Object = null):void {    	    	var currentTime:Number = youTubePlayer.getCurrentTime();	    youTubePlayer.loadVideoById(clip.url,currentTime);	    dispatchEvent(event);    }        protected final function dispatchEvent(event:ClipEvent):void {		if (! event) return;		log.debug("dispatching " + event + " on clip " + clip);		clip.dispatchEvent(event);	}		private function dispatchError(error:ClipError, info:String):void {		clip.dispatchError(error, info);	}		public function getVideo(clip:Clip):DisplayObject {		return _playerLoader;	}		public function attachStream(video:DisplayObject):void {			}		public function get fileSize():Number {		if (!youTubePlayer) return 0;		return youTubePlayer.getVideoBytesTotal();	}		public function get time():Number {		if (!youTubePlayer) return 0;		return getCurrentPlayheadTime();	}		protected function getCurrentPlayheadTime():Number {        return youTubePlayer.getCurrentTime();	}		protected final function get clip():Clip {		return _playlist.current;	}		public function get bufferStart():Number {        if (! clip) return 0;        return _bufferStart - clip.start;    }    public function get bufferEnd():Number {        if (! clip) return 0;        if (!youTubePlayer) return 0;        return bufferStart + youTubePlayer.getVideoBytesLoaded()/youTubePlayer.getVideoBytesTotal() * (clip.duration - bufferStart);    }        public function set volumeController(controller:VolumeController):void {    	_volumeController = controller;    }        public function stopBuffering():void {    	    }        public function get stopping():Boolean {    	return _stopping;    }        public function set playlist(playlist:Playlist):void {    	_playlist = playlist;    }		public function get playlist():Playlist {		return _playlist;	}		public function addConnectionCallback(name:String, listener:Function):void {			}		public function addStreamCallback(name:String, listener:Function):void {			}		public function get netStream():NetStream {		return null;	}		public function get netConnection():NetConnection {		return null;	}		public function set timeProvider(timeProvider:TimeProvider):void {		_timeProvider = timeProvider;	}		protected final function get paused():Boolean {		return _paused;	}		protected final function get seeking():Boolean {    	return _seeking;    }        protected final function set silentSeek(value:Boolean):void {		_silentSeek = value;		log.info("silent mode was set to " + _silentSeek);	}			protected final function get silentSeek():Boolean {		return _silentSeek;	}    protected final function set seeking(value:Boolean):void {    	_seeking = value;    }    public function get allowRandomSeek():Boolean {       return true;    }        protected function canDispatchBegin():Boolean {		return true;	}   	   	protected function canDispatchStreamNotFound():Boolean {		return true;	}		    public function getDefaultConfig():Object {        return null;    }        public function get type():String {		return "youtube";		}		public function handeNetStatusEvent(event:NetStatusEvent):Boolean {    	return true;    }            public function set onFailure(listener:Function):void {		_failureListener = listener;    }	public function resolve(provider:StreamProvider, clip:Clip, successListener:Function):void {				//strip api: from the clip url to obtain the id		var url:String = clip.url.split(":")[1];		clip.setResolvedUrl(this, url);		_successListener = successListener;		//setup the player to initially obtain the quality levels before resolving the clip and playing the video.		setupPlayer();      	setupApiLoader();			}  }}