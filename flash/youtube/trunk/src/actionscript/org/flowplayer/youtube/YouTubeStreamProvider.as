/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008, 2009 Flowplayer Oy * H.264 support by: Arjen Wagenaar, <h264@code-shop.com> * Copyright (c) 2009 CodeShop B.V. * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.youtube {import org.flowplayer.model.ClipEvent;import org.flowplayer.controller.StreamProvider;import org.flowplayer.util.Log;import org.flowplayer.model.ClipEventType;import org.flowplayer.model.Plugin;import org.flowplayer.model.PluginModel;import org.flowplayer.model.ProviderModel;import org.flowplayer.util.PropertyBinder;import org.flowplayer.view.Flowplayer;import flash.events.NetStatusEvent;import org.flowplayer.model.Clip;import flash.net.NetStream;import flash.net.NetConnection;import flash.display.DisplayObject;import flash.net.URLLoader;import flash.net.URLRequest;import flash.net.URLVariables;import flash.display.Loader;import flash.events.Event;import flash.events.IOErrorEvent;import org.flowplayer.controller.TimeProvider;import org.flowplayer.controller.VolumeController;import org.flowplayer.model.Playlist;import org.flowplayer.view.AbstractSprite;	/**     * @author api     *///public class YouTubeStreamProvider extends NetStreamControllingStreamProvider implements Plugin {public class YouTubeStreamProvider extends AbstractSprite implements Plugin,StreamProvider {	    private var _config:Config;    private var _model:PluginModel;        private var _bufferStart:Number;    private var apiLoader:URLLoader;    private var playerLoader:Loader;    private var youTubePlayer:Object;    private var _player:Flowplayer;    private var _clip:Clip;   // protected var log:Log = new Log(this);    private var _stopping:Boolean;    private var _playlist:Playlist;    private var _timeProvider:TimeProvider;    /**     * Called by the player to set my config.     */    public function onConfig(model:PluginModel):void {    	log.error("onConfig");        _model = model;        _config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;    }        public function set model(model:ProviderModel):void {		_model = model;		onConfig(model);	}		public function set player(player:Flowplayer):void {		_player = player;		onLoad(player);	}		public function onLoad(player:Flowplayer):void { 		_model.dispatchOnLoad();	}    /**     * Called by the player to set the Flowplayer API.     */  /*  override public function onLoad(player:Flowplayer):void {    	        log.info("onLoad, registering metadata listener");        _model.dispatchOnLoad();    }*/        private function setupPlayer():void {      playerLoader = new Loader();      playerLoader.contentLoaderInfo.addEventListener(Event.INIT, playerInitHandler);      playerLoader.load(new URLRequest(_config.apiPlayerURL));          }        private function setupApiLoader():void {      apiLoader = new URLLoader();      apiLoader.addEventListener(IOErrorEvent.IO_ERROR,                                        apiLoaderErrorHandler);      apiLoader.addEventListener(Event.COMPLETE,                                        apiLoaderCompleteHandler);    }         private function apiLoaderCompleteHandler(event:Event):void {      var atomData:String = apiLoader.data;      var atomXml:XML = new XML(atomData);            log.debug(atomXml);      //var aspectRatios:XMLList = atomXml..*::aspectRatio;      //isWidescreen = aspectRatios.toString() == WIDESCREEN_ASPECT_RATIO;       youTubePlayer.loadVideoById(_clip.url);    }        private function requestApiURL():void {      var request:URLRequest = new URLRequest(_config.gdataApiURL + _clip.url);      var urlVariables:URLVariables = new URLVariables();      urlVariables.v = _config.gdataApiVersion;      urlVariables.format = _config.gdataApiFormat;      request.data = urlVariables;      try {        apiLoader.load(request);      } catch (error:SecurityError) {        log.error("A SecurityError occurred while loading", request.url);      }    }        private function apiLoaderErrorHandler(event:IOErrorEvent):void {      log.error("Error making YouTube API request:", event);    }        private function playerInitHandler(event:Event):void {    	      //_player.addToPanel(playerLoader,{width: _player.screen.widthPx, height: _player.screen.heightPx });            addChild(playerLoader);      playerLoader.content.addEventListener("onReady", onPlayerReady);      playerLoader.content.addEventListener("onError", onPlayerError);      playerLoader.content.addEventListener("onStateChange",                                            onPlayerStateChange);      playerLoader.content.addEventListener("onPlaybackQualityChange",                                            onVideoPlaybackQualityChange);                                                                                            }        private function onPlayerReady(event:Event):void {      youTubePlayer = playerLoader.content;            requestApiURL();    }    private function onPlayerError(event:Event):void {      trace("Player error:", Object(event).data);    }    private function onPlayerStateChange(event:Event):void {      trace("State is", Object(event).data);      switch (Object(event).data) {        case YouTubePlayerState.ENDED:          break;        case YouTubePlayerState.PLAYING:          break;        case YouTubePlayerState.PAUSED:                    break;		case YouTubePlayerState.BUFFERING:				break;        case YouTubePlayerState.CUED:          //resizePlayer("medium");          break;      }    }    private function onVideoPlaybackQualityChange(event:Event):void {      //trace("Current video quality:", Object(event).data);      //resizePlayer(Object(event).data);    }    /*    override protected function getClipUrl(clip:Clip):String {        return clip.completeUrl;    }        override protected function onClipUrlResolved(clip:Clip):void {    	dispatchEvent(new ClipEvent(ClipEventType.CONNECT));    }        override  protected function connect(clip:Clip, ... rest):void {    	//resolveClipUrl(clip, onClipUrlResolved);    }*/	public function load(event:ClipEvent, clip:Clip, pauseAfterStart:Boolean = true):void {        log.info("doLoad");        _stopping = false;        _clip = clip;        setupPlayer();      	setupApiLoader();    }				public function stop(event:ClipEvent, closeStream:Boolean = false):void {		_stopping = true;		youTubePlayer.stopVideo();	}	    public function seek(event:ClipEvent, seconds:Number):void {        var target:Number = _clip.start + seconds;    	youTubePlayer.seekTo(target, true);    }        public function pause(event:ClipEvent):void {    	_stopping = false;    	youTubePlayer.pauseVideo();      }        public function resume(event:ClipEvent):void {    	_stopping = false;    	youTubePlayer.playVideo();    }            public function switchStream(event:ClipEvent, clip:Clip, netStreamPlayOptions:Object = null):void {    	    	var currentTime:Number = youTubePlayer.getCurrentTime();    	    		    youTubePlayer.loadVideoById(clip.url);	    youTubePlayer.seekTo(currentTime, true);    	    }		public function getVideo(clip:Clip):DisplayObject {		return {} as DisplayObject;	}		public function attachStream(video:DisplayObject):void {			}		public function get fileSize():Number {		if (!youTubePlayer) return 0;		return youTubePlayer.getBytesTotal();	}		public function get time():Number {		if (!youTubePlayer) return 0;        return youTubePlayer.getCurrentTime();	}		public function get bufferStart():Number {        if (! _clip) return 0;        return _bufferStart - _clip.start;    }    public function get bufferEnd():Number {        if (! _clip) return 0;        if (!youTubePlayer) return 0;        return bufferStart + youTubePlayer.getBytesLoaded()/youTubePlayer.getBytesTotal() * (youTubePlayer.getDuration() - bufferStart);    }        public function set volumeController(controller:VolumeController):void {    	    }        public function stopBuffering():void {    	    }        public function get stopping():Boolean {    	return _stopping;    }        public function set playlist(playlist:Playlist):void {    	_playlist = playlist;    }		public function get playlist():Playlist {		return _playlist;	}		public function addConnectionCallback(name:String, listener:Function):void {			}		public function addStreamCallback(name:String, listener:Function):void {			}		public function get netStream():NetStream {		return null;	}		public function get netConnection():NetConnection {		return null;	}		public function set timeProvider(timeProvider:TimeProvider):void {		_timeProvider = timeProvider;	}		    public function get allowRandomSeek():Boolean {       return true;    }           public function getDefaultConfig():Object {        return null;    }        public function get type():String {		return "youtube";		}}}