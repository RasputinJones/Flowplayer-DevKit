/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com> * Copyright (c) 2008 Electroteque Multimedia * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.rtmp.bwcheck {	import flash.events.NetStatusEvent;	import flash.net.SharedObject;		import mx.utils.StringUtil;		import org.flowplayer.model.Clip;	import org.flowplayer.model.ClipEvent;	import org.flowplayer.model.Plugin;	import org.flowplayer.model.PluginModel;	import org.flowplayer.rtmp.bwcheck.servers.FMSServerClientBandwidth;	import org.flowplayer.rtmp.bwcheck.servers.WowzaServerClientBandwidth;	import org.flowplayer.rtmp.bwcheck.servers.HttpServerClientBandwidth;	import org.flowplayer.rtmp.cluster.RTMPClusterStreamProvider;	import org.flowplayer.util.PropertyBinder;	import org.red5.flash.bwcheck.ServerClientBandwidth;	import org.red5.flash.bwcheck.events.BandwidthDetectEvent;	import org.flowplayer.rtmp.bwcheck.event.BWDetectEventType;		/**	 * A RTMP stream provider with fallback, clustering support, bitrate detection and bitrate choosing support. Supports following:	 * <ul>	 * <li>Starting in the middle of the clip's timeline using the clip.start property.</li>	 * <li>Stopping before the clip file ends using the clip.duration property.</li>	 * <li>Ability to combine a group of clips into one gapless stream.</li>	 * <li>Ability to do dowload bitrate detection against a supported bitrate detection application running on FMS, Wowza or Red5 streaming server.</li>	 * <li>Ability to set a given list of available bitrates and choose the file given by a file naming convention format.</li>	 * <li>Ability to fallback to a list of servers in a cluster server farm.</li>	 * <li>Ability to recognise, store and leave out any failed servers for a given time.</li>	 * <li>Ability to randomly connect to a server in the servers list mimicking a round robin connection.</li>	 * <li>Works with a traditional load balancing appliance by feeding its host at the top of the list, and direct connections to the servers happen on fallback.</li>	 * </ul>	 * <p>	 * Stream group is configured in a clip like this:	 * <code>	 * { streams: [ { url: 'metacafe', duration: 20 }, { url: 'honda_accord', start: 10, duration: 20 } ] }	 * </code>	 * The group is played back seamlessly as one gapless stream. The individual streams in a group can	 * be cut out from a larger file using the 'start' and 'duration' properties as shown in the example above.	 * 	 * Bitrate Detection Mode:	 * 	 * <p>	 * A netBWConnectionUrl config property is required to give the url of the bitrate detection server application location like so:	 * 	 * netBWConnectionUrl: 'rtmp://localhost/bwcheck'	 * 	 * <p> 	 * To enable server fallback for the bitrate detection hosts a bwHosts config property is required in the plugins config like this:	 * 	 * bwHosts: [	 *	       'rtmp://server1.host.com/bwcheck',	 *	       'rtmp://server2.host.com/bwcheck',	 *	       'rtmp://server3.host.com/bwcheck',	 *	      ]	 * 	 * <p>	 * To determine which server the plugin is handling the detection for and which implementation to choose a serverType config is required like so:	 * 	 * serverType: 'red5' (red5, wowza or fms)	 * 	 * <p>	 * The bitrate detection feature requires a list of available bitrates to choose from like so:	 * 	 * bitrates: [  	 * 	           100,300,500,700	 *	         ],	 * 	 * <p> A defaultBitrate config property is also required as a fallback if the bitrate choosing fails like so:	 * 	 * defaultBitrate: 300	 * 	 * <p> A fileNameString config property is also required to determine the file naming convention format like so:	 * 	 * fileNameString: '{0}-{1}.{2}' Where {0} is the filename, {1} is the bitrate and {2} is the file extension	 * 	 * <p>	 * 	 * Possible options are {0}-{1}, {0}_{1}, {1}-{0}, {1}_{0}, {0}-{1}.{2}, {0}_{1}.{2}	 * 	  <p>	 * Advanced configurations for the bandwidth detection feature can be enabled like so:	 * 	 * closestRateInterval: 100,	 * rememberBitrate: false (default: true)	 * 	 * <p>	 * closestRateInterval determines which nearest rate will use the highest rate (ie detected bandwidth is 600 will choose the highest rate of 700).	 * rememberBitrate enables or disables storing the chosen bitrate to enabled bandwidth detection on each request.	 * 	 * <p> Four custom events a fired during connection attempts and fallback, these are:	 * 	 * <ul>	 * <li>BWDetectEventType.DETECT_COMPLETE - onDetectComplete</li>	 * <li>BWDetectEventType.DETECT_FAILED - onDetectFailed</li>	 * <li>BWDetectEventType.DETECT_START - onDetectStart</li>	 * <li>BWDetectEventType.DETECT_STATUS - onDetectStatus</li>	 * </ul>	 * 	 * Clustering Mode:	 * 	 * <p> 	 * To enable server fallback a hosts config property is required in the plugins config like this:	 * 	 * hosts: [	 *	       'rtmp://server1.host.com/myapp',	 *	       'rtmp://server2.host.com/myapp',	 *	       'rtmp://server3.host.com/myapp',	 *	      ]	 * 	 * <p>	 * To enable the fallback feature to store (client side) failed servers to prevent reattempting those connections the failureExpiry config property is required like so:	 * failureExpiry: 3000,	 * 	 * <p> This tells the feature to wait for 3000 milliseconds before allowing connection attempts again. 	 * 	 * <p>	 * To enable round robin connections the loadBalanceServers config property requires to be enabled like so:	 * 	 * loadBalanceServers: true	 * 	 * <p>	 * Advanced configurations for the fallback feature can be enabled like so:	 * 	 * connectTimeout: 5000,	 * connectCount: 3	 * encoding: 0	 * 	 * <p> connectTimeout is the time in milliseconds before each reconnection attempt.	 * connectCount is the ammount of times connection reattmps will occur before giving up.	 * encoding is the AMF encoding version either 0 or 3 for AMF3.	 * 	 * <p> Two custom events a fired during connection attempts and fallback, these are:	 * 	 * <ul>	 * <li>RTMPEventType.RECONNECTED - onReconnect</li>	 * <li>RTMPEventType.FAILED - onFailed</li>	 * </ul>	 * 	 * @author danielr	 */	public class RTMPBWStreamProvider extends RTMPClusterStreamProvider implements Plugin {		private var _config:RTMPBWConfig;		private var _startAfterConnect:Boolean;		private var _hasDetectedBW:Boolean = false;		private var _detectionClass:Class;		private var _serviceMethod:String;		private var _bitrate:Number;		private var _chosenBitrate:String;		private var _bitrateProfile:SharedObject = SharedObject.getLocal("bitrateProfile","/");				/**		 * Called by the player to set my model object.		 */		override public function onConfig(model:PluginModel):void {						_config = new PropertyBinder(new RTMPBWConfig(), null).copyProperties(model.config) as RTMPBWConfig;			_chosenBitrate = _bitrateProfile.data.chosenBitrate;			super.onConfig(model);		}						/**		 * Override getHosts to determine if to get set the live online servers list for the bitrate detection or playback 		 */		 		override protected function getHosts():Array		{			return hasDetectedBW() ? super.getHosts() :			_config.bwHosts.filter(checkLiveHost);		}				/**		 * Check to see if the available online servers list is enabled		 */		protected function hasMultipleBWHosts():Boolean		{			return _config.bwHosts.length > 0;		}				/**		 * Checks to see if bitrate detection has already happened.		 */		protected function hasDetectedBW():Boolean		{			if (_bitrateProfile.data.detectedBitrate || _hasDetectedBW) return true;			return false;		}				/**		 * Gets the clip url by first doing a substitution of the file name format		 */		override protected function getClipUrl(clip:Clip):String {			var name:String = clip.url.substring(0,clip.url.lastIndexOf("."));			var ext:String = clip.url.substring(clip.url.lastIndexOf(".") + 1,clip.url.length);			var file:String = StringUtil.substitute(_config.fileNameString,name,_chosenBitrate,ext);			log.info("Playing File: " + file);			return file;		}				/**		 * Start the bandwidth check connection only if a detection hasn't already happened.		 */		override protected function connect(clip:Clip, startAfterConnect:Boolean = false, ... rest):void {			_startAfterConnect = startAfterConnect;			if (!hasDetectedBW())			{				doBWConnect();			} else {				super.connect(clip, startAfterConnect);			}		}				/**		 * Start the bandwidth check connection depending on the serverType.		 * By default the FMS implementation requires a true property to the first of the connection arguments.		 * The other server implementations don't require this as they use AMF service callback methods.		 */		public function doBWConnect():void		{			switch(_config.serverType)			{					case "fms":						super.connect(clip, false, true);					break;					case "wowza":						super.connect(clip, false);					break;					case "http":						super.connect(clip, false);					break;					default:						super.connect(clip, false);					break;			}		}				/**		 * Gets the connection URI to connect to the media server app.		 */		override protected function getConnectUrl(clip:Clip):String {			var server:String;						if (!hasDetectedBW())			{					if (_config.serverType == "http") return null;				return hasMultipleBWHosts() ? super.getConnectUrl(clip) : _config.netBWConnectionUrl;			} else {				liveServers = getHosts();				server =  super.getConnectUrl(clip);				log.info("Connecting to " + server);				return server;			}		}				override public function onBWDone(... rest):void		{			}		public function onBWCheck(... rest):void		{		}				/**		 * This can be called externally from javascript to initiate a bandwidth detection.		 */		[External]		public function checkBandwidth():void		{			netConnection.close();			_bitrateProfile.data.detectedBitrate = null;			_hasDetectedBW = false;			liveServers = getHosts();			doBWConnect();		}				/**		 * Determine the server type to choose which way to handle the bandwidth detection and run the detection.		 */		protected function doDetection():void		{			log.debug("detecting bandwidth");			dispatchEvent(new ClipEvent(BWDetectEventType.DETECT_START));			switch(_config.serverType)			{				case "fms":					var detectFMS:FMSServerClientBandwidth = new FMSServerClientBandwidth();					detectFMS.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE,onServerClientComplete);					detectFMS.addEventListener(BandwidthDetectEvent.DETECT_STATUS,onServerClientStatus);					detectFMS.addEventListener(BandwidthDetectEvent.DETECT_FAILED,onDetectFailed);					detectFMS.connection = netConnection;					detectFMS.start();				break;				case "wowza":					var detectWowza:WowzaServerClientBandwidth = new WowzaServerClientBandwidth();					detectWowza.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE,onServerClientComplete);					detectWowza.addEventListener(BandwidthDetectEvent.DETECT_STATUS,onServerClientStatus);					detectWowza.addEventListener(BandwidthDetectEvent.DETECT_FAILED,onDetectFailed);					detectWowza.connection = netConnection;					detectWowza.service = "checkBandwidth";					detectWowza.start();				break;				case "http":					var detectHttp:HttpServerClientBandwidth = new HttpServerClientBandwidth();					detectHttp.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE,onServerClientComplete);					detectHttp.addEventListener(BandwidthDetectEvent.DETECT_STATUS,onServerClientStatus);					detectHttp.addEventListener(BandwidthDetectEvent.DETECT_FAILED,onDetectFailed);					detectHttp.connection = netConnection;					detectHttp.url = _config.netBWConnectionUrl;					//detectHttp.service = "checkBandwidth";					detectHttp.start();				break;				default:						var detect:ServerClientBandwidth = new ServerClientBandwidth();					detect.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE,onServerClientComplete);					detect.addEventListener(BandwidthDetectEvent.DETECT_STATUS,onServerClientStatus);					detect.addEventListener(BandwidthDetectEvent.DETECT_FAILED,onDetectFailed);					detect.connection = netConnection;					detect.service = "bwCheckService.onServerClientBWCheck";					detect.start();				break;			}		}				/**		 * Called when a detection has failed		 */		public function onDetectFailed(event:BandwidthDetectEvent):void		{			event.stopPropagation();			log.error("\n Detection failed with error: " + event.info.application + " " + event.info.description);			dispatchEvent(new ClipEvent(BWDetectEventType.DETECT_FAILED));		}				/**		 * Called when a detection has completed and set the bandwidth properties from the returned values		 */		 		public function onServerClientComplete(event:BandwidthDetectEvent):void		{			event.stopPropagation();			log.info("\n\n kbit Down: " + event.info.kbitDown + " Delta Down: " + event.info.deltaDown + " Delta Time: " + event.info.deltaTime + " Latency: " + event.info.latency);			_hasDetectedBW = true;						// Set the detected bandwidth			_bitrate = event.info.kbitDown;						// Choose a rate from the given bitrates list or return the default rate			_chosenBitrate = getBitrate(_bitrate, _config.bitrates, _config.defaultBitrate, _config.closestRateInterval);						// Store the bitrate to prevent further bitrate detections			rememberBitrate(_chosenBitrate, _bitrate);			dispatchEvent(new ClipEvent(BWDetectEventType.DETECT_COMPLETE));			netConnection.close();			super.connect(clip,true);					}				/**		 * Called during the bitrate detection checking and return its status		 */		public function onServerClientStatus(event:BandwidthDetectEvent):void		{				if (event.info) {				log.info("\n count: "+event.info.count+ " sent: "+event.info.sent+" timePassed: "+event.info.timePassed+" latency: "+event.info.latency+" cumLatency: " + event.info.cumLatency);				dispatchEvent(new ClipEvent(BWDetectEventType.DETECT_STATUS));			}		}				/**		 * Returns the chosen bitrate		 */		public function getChosenBitrate():String		{			return _chosenBitrate;		}				/**		 * Returns the detected bitrate		 */		public function getDetectedBitrate():int		{			return _bitrate;		}				/**		 * Star the bandwidth detection if a connection is successful		 */				override protected function onNetStatus(event:NetStatusEvent):void {						if (!hasDetectedBW())			{				switch (event.info.code) 				{					//connection is successful stop any reconnection attempts					case "NetConnection.Connect.Success":						doDetection();						//stopReconnect();					break;					//connection has failed, reattempt using the fallback system					case "NetConnection.Connect.Failed":						log.info("Couldnt connect to " + netConnection.uri);					break;					//connection has closed					case "NetConnection.Connect.Closed":							break;				}			}			super.onNetStatus(event);						//log.debug(event.info.code);		}				/**		 * Determine the chosen bitrate from a given list of bitrates		 * The default bitrate is chosen on fallback of choosing a rate.		 * The highest possible rate is chosen if a clients bandwidth is above or below the highest rate determined by the closestRateInterval config property.		 */		protected function getBitrate(kBDown:int, bitrates:Array, defaultBitrate:String, closestRateInterval:int):String		{			var bitrate:String = defaultBitrate;			var rates:Array = bitrates.concat();				rates.sort(Array.NUMERIC, Array.DESCENDING).reverse()						var largest_rate:String = rates[0];									for (var i:int = 0; i < rates.length; i++) {				if (kBDown >= Number(largest_rate))				{					bitrate = largest_rate;					return bitrate;				} else if (kBDown >= (rates[i] - closestRateInterval)) {					bitrate = rates[i];					return bitrate;				} else if (kBDown < Number(rates[i])) {					bitrate = rates[i];				}			}							return bitrate;		}				/**		 * Store the detection and chosen bitrate if the rememberBitrate config property is set.		 */		protected function rememberBitrate(chosenBitrate:String, detectedBitrate:int):void		{						if (_config.rememberBitrate) {				_bitrateProfile.data.chosenBitrate = chosenBitrate;				_bitrateProfile.data.detectedBitrate = detectedBitrate;			}		}	}}