/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com> * Copyright (c) 2009 Electroteque Multimedia * * Copyright 2009 Joel Hulen, loading of captions files from URLs without a file extension * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.captions {    import flash.events.MouseEvent;    import flash.utils.clearInterval;    import flash.utils.setInterval;    import org.flowplayer.captions.parsers.CaptionParser;import org.flowplayer.captions.parsers.JSONParser;    import org.flowplayer.captions.parsers.SRTParser;    import org.flowplayer.captions.parsers.TTXTParser;    import org.flowplayer.controller.ResourceLoader;    import org.flowplayer.layout.LayoutEvent;    import org.flowplayer.model.Clip;    import org.flowplayer.model.ClipEvent;    import org.flowplayer.model.DisplayPluginModel;    import org.flowplayer.model.PlayerEvent;    import org.flowplayer.model.Plugin;    import org.flowplayer.model.PluginModel;    import org.flowplayer.util.PropertyBinder;    import org.flowplayer.view.AbstractSprite;    import org.flowplayer.view.FlowStyleSheet;    import org.flowplayer.view.Flowplayer;    import org.flowplayer.view.Styleable;    /**	 * A Subtitling and Captioning Plugin. Supports the following:	 * <ul>	 * <li>Loading subtitles from the Timed Text or Subrip format files.</li>	 * <li>Styling text from styles set in the Time Text format files.</li>	 * <li>Loading subtitles or cuepoints from a JSON config.</li>	 * <li>Loading subtitles or cuepoints from embedded FLV cuepoints.</li>	 * <li>Controls an external content plugin.</li>	 * <li>Working with the Javascript captions plugin, it enables a scrolling cuepoint thumbnail menu.</li>	 * </ul>	 * <p>	 * To setup an external subtitle caption file the config would look like so:	 * 	 * captionType: 'external'	 * 	 * For Timed Text	 *	 * captionUrl: 'timedtext.xml'	 * 	 * For Subrip	 * 	 * captionUrl: 'subrip.srt'	 * 	 * <p>	 * To enable the captioning to work properly a caption target must link to a content plugin like so:	 * 	 * captionTarget: 'content'	 * 	 * Where content is the config for a loaded content plugin.	 *	 * <p>	 * 	 * To be able to customised the subtitle text a template string is able to tell the captioning plugin	 * which text property is to be used for the subtitle text which is important for embedded cuepoints. It also	 * enables to add extra properties to the text like so:	 * 	 * template: '{text} {time} {custom}' 	 * 	 * <p>	 * To enable simple formatting of text if Timed Text has style settings, 	 * only "fontStyle", "fontWeight" and "textAlign" properties are able to be set like so:	 * 	 * simpleFormatting: true	 * 	 * @author danielr	 */	public class Caption extends AbstractSprite implements Plugin, Styleable {		private var _captions:Array = new Array();		private var _player:Flowplayer;		private var _model:PluginModel;		private var _captionView:*;		private var _config:Config;		private var _styles:FlowStyleSheet;		private var _viewModel:DisplayPluginModel;		private var _captionInterval:int;		private var template:String;        private var _button:CCButton;				public function Caption() {				}				/**		 * Sets the plugin model. This gets called before the plugin		 * has been added to the display list and before the player is set.		 * @param plugin		 */		public function onConfig(plugin:PluginModel):void {			_model = plugin;			_config = new PropertyBinder(new Config(), null).copyProperties(plugin.config) as Config;			if (plugin.config) {				//log.debug("config object received with html " + plugin.config.html + ", stylesheet " + plugin.config.stylesheet);				_captions = _config.captions;			}		}				public function hasCaptionFile():Boolean		{			var clips:Array = _player.playlist.clips;			for (var i:Number = 0; i < clips.length; i++) {				var clip:Clip = clips[i] as Clip;				if (clip.customProperties && clip.customProperties["captionUrl"]) {					return true;				}			}			return false;		}				public function hasCaptions():Boolean		{			return _captions.length > 0;		}				/**		 * Sets the Flowplayer interface. The interface is immediately ready to use, all		 * other plugins have been loaded an initialized also.		 * @param player		 */		public function onLoad(player:Flowplayer):void {			_player = player;			_player.playlist.onCuepoint(onCuepoint);						if (! _config.captionTarget) {				throw Error("No captionTarget defined in the configuration");			}			_viewModel = _player.pluginRegistry.getPlugin(_config.captionTarget) as DisplayPluginModel;			_captionView = _viewModel.getDisplayObject();			_player.onLoad(onPlayerInitialized);									if (hasCaptionFile()) {				loadCaptionFiles();			} else {			    _model.dispatchOnLoad();			}		}		private function onPlayerInitialized(event:PlayerEvent):void {		    initCaptionView();            log.debug("button", _config.button);            if (_config.button) {                _button = new CCButton(_player, _config.button["label"]);                _player.addToPanel(_button, _config.button);                _button.isDown = _viewModel.visible;                _button.addEventListener(MouseEvent.CLICK, function(event:MouseEvent):void {                    _button.isDown = _player.togglePlugin(_config.captionTarget);                });            }		}        private function onPlayerResized(event:LayoutEvent):void {            log.debug("onPlayerResized");            _button.x = _captionView.x + _captionView.width + 3;            _button.y = _captionView.y;        }				private function loadCaptionFiles():void {			var clips:Array = _player.playlist.clips;			for (var i:Number = 0; i < clips.length; i++) {				var clip:Clip = _player.playlist.clips[i] as Clip;				var captionUrl:String = clip.customProperties ? clip.customProperties["captionUrl"] : null; 				if (captionUrl) {					loadCaptionFile(clip, captionUrl, null);				}			}		}		/**		 * Loads a new stylesheet and changes the style from the loaded sheet.         * @param clipIndex         * @param captionURL the URL to load the caption file from         * @param fileExtension optional file extension to be used if captionURL does not use an extension, one of         * 'xml', 'srt', 'tx3g', 'qtxt'		 */		 [External]		public function loadCaptions(clipIndex:int, captionURL:String, fileExtension:String = null):void {			if (! captionURL) return;			log.info("loading captions from "+ captionURL);			loadCaptionFile(_player.playlist.clips[clipIndex], captionURL, fileExtension);		}		/**		 * Sets style properties.		 */		public function css(styleProps:Object = null):Object {			var result:Object = _captionView.css(styleProps);			return result;		}		/**		 * Joel Hulen - April 20, 2009		 * Modified loadCaptionFile to add the fileExtension parameter.		 */		protected function loadCaptionFile(clip:Clip, captionFile:String = null, fileExtension:String = null):void {			var loader:ResourceLoader = _player.createLoader();			if (captionFile) {				log.info("loading captions from file " + captionFile);				loader.addTextResourceUrl(captionFile);			}					loader.load(null, function(loader:ResourceLoader):void {				parseCuePoints(clip, captionFile, loader.getContent(captionFile), fileExtension);			});		}				protected function parseCuePoints(clip:Clip, captionFile:String, captionData:*, fileExtension:String = null):void		{            log.debug("captions file loaded, parsing cuepoints");            var parser:CaptionParser = createParser(fileExtension || captionFile.substr(-3), captionData);            try {                clip.addCuepoints(parser.parse(_captions.length > 0 ? _captions : captionData));            } catch (e:Error) {                log.error(e.message);            }            _captionView.style = parser.styles;            _model.dispatchOnLoad();        }        private function createParser(fileExtension:String, captionData:Object):CaptionParser {            var parser:CaptionParser;            if (_captions.length > 0) {                parser = new JSONParser();            } else if (captionData) {                if (fileExtension == CaptionFileTypes.TTXT) {                    log.debug("parsing Timed Text captions");                    parser = new TTXTParser();                    TTXTParser(parser).simpleFormatting = _config.simpleFormatting;                } else if (fileExtension == CaptionFileTypes.SRT) {                    log.debug("parsing SubRip captions");                    parser = new SRTParser();                }  else {                    throw new Error("Unrecognized captions file extension");                }            }            parser.styles = _captionView.style;            return parser;        }				protected function parseTemplate(values:Object):String		{			for (var key:String in values) {				if (typeof values[key] == 'object')				{						parseTemplate(values[key]);				} else {					template = template.replace("{" + key + "}", values[key]);				}			}			if (values.time >= 0) {				template = template.replace("{time}", values.time);			}						return template;		}				protected function clearCaption():void		{			if (_captionInterval == -1) return;			clearInterval(_captionInterval);			_captionInterval = -1;			_captionView.html = "";		}				protected function onCuepoint(event:ClipEvent):void {			log.debug("onCuepoint", event.info.parameters);						var clip:Clip = event.target as Clip;			var captionsDisabledForClip:Boolean = clip.customProperties && clip.customProperties.hasOwnProperty("showCaptions") && ! clip.customProperties["showCaptions"]; 			if (captionsDisabledForClip) {				return;			}						if (clip.customProperties && clip.customProperties.hasOwnProperty("captionUrl")) {				var cue:Object = event.info;				if (! cue.hasOwnProperty("captionType") || cue["captionType"] != "external") {					// we are using a captions file and this cuepoint is not from the file					return;				}			}						clearInterval(_captionInterval);			_captionInterval = -1;			template = _config.template;			var bgColor:String = (_captionView.style.getStyle("." + event.info.parameters.style).backgroundColor ? _captionView.style.getStyle("." + event.info.parameters.style).backgroundColor			: _captionView.style.rootStyle.backgroundColor);			_captionView.css({backgroundColor: bgColor});			_captionView.html = "<p class='"+event.info.parameters.style+"'>" + (template ? parseTemplate(event.info) : event.info.parameters.text) + "</p>";		    if (Number(event.info.parameters.end) > 0) _captionInterval = setInterval(clearCaption, Number(event.info.parameters.end));	    		}		protected function initCaptionView():void {			log.debug("creating content view");			if (_config.captionTarget)			{				log.info("Loading caption target plugin: " + _config.captionTarget);												if (_config.autoLayout)				{					_captionView.css(getDefaultConfig());				}			} else {				throw new Error("No caption target specified, please configure a Content plugin instance to be used as target");			}			_viewModel.alpha = 0;		}				public override function set alpha(value:Number):void {			super.alpha = value;			if (!_captionView) return;			_captionView.alpha = value;		}		public function getDefaultConfig():Object {			return { bottom: 25, width: '80%'};		}				public function animate(styleProps:Object):Object {			return _captionView.animate(styleProps);		}			}}