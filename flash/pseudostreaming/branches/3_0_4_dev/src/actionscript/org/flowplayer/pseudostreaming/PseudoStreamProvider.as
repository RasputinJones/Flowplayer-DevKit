/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008, 2009 Flowplayer Oy * H.264 support by: Arjen Wagenaar, <h264@code-shop.com> * Copyright (c) 2009 CodeShop B.V. * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.pseudostreaming {import org.flowplayer.model.ClipEvent;import org.flowplayer.controller.NetStreamControllingStreamProvider;import org.flowplayer.model.ClipEventType;import org.flowplayer.model.Plugin;import org.flowplayer.model.PluginModel;import org.flowplayer.util.PropertyBinder;import org.flowplayer.view.Flowplayer;import flash.events.NetStatusEvent;import org.flowplayer.model.Clip;import flash.net.NetStream;    /**     * @author api     */public class PseudoStreamProvider extends NetStreamControllingStreamProvider implements Plugin {    private var _bufferStart:Number;    private var _config:Config;    private var _clipWithKeyframeInfo:Clip;    private var _serverSeekInProgress:Boolean;    private var _startSeekDone:Boolean;    private var _model:PluginModel;    private var _seekDataStore:DefaultSeekDataStore;    /**     * Called by the player to set my config.     */    override public function onConfig(model:PluginModel):void {        _model = model;        _config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;    }    /**     * Called by the player to set the Flowplayer API.     */    override public function onLoad(player:Flowplayer):void {        log.info("onLoad, registering metadata listener");        _model.dispatchOnLoad();    }    override protected function doLoad(event:ClipEvent, netStream:NetStream, clip:Clip):void {        log.info("doLoad");        _bufferStart = clip.start;        _startSeekDone = false;        if (! _seekDataStore || clip != _clipWithKeyframeInfo) {            _seekDataStore = new DefaultSeekDataStore();        }        _seekDataStore.prevSeekTime = 0;        super.doLoad(event, netStream, clip);    }    /**     * Appends a query string to the specified resolved URL and calls super.     * @param url     * @return     */    override protected function getClipUrl(clip:Clip):String {        var url:String = appendQueryString(clip.completeUrl, 0);        log.debug("getClipUrl returning " + url);        return url;    }    override protected function doSeek(event:ClipEvent, netStream:NetStream, seconds:Number):void {        var target:Number = clip.start + seconds;        if (isInBuffer(target)) {            log.debug("seeking inside buffer, target " + target + " seconds");            netStream.seek(_seekDataStore.inBufferSeekTarget(target));        } else {            serverSeek(netStream, target);        }    }    //		override protected function doStop(event:ClipEvent, netStream:NetStream):void {    //			silentSeek = true;    //			doSeek(null, netStream, 0);    //			netStream.pause();    //			dispatchEvent(event);    //		}    override public function get bufferStart():Number {        if (! clip) return 0;        return _bufferStart - clip.start;    }    override public function get bufferEnd():Number {        if (! netStream) return 0;        if (! clip) return 0;        return bufferStart + netStream.bytesLoaded/netStream.bytesTotal * (clip.duration - bufferStart);    }    override protected function getCurrentPlayheadTime(netStream:NetStream):Number {        if (! clip) return 0;        var value:Number = _seekDataStore.currentPlayheadTime(netStream.time, clip.start);        return value < 0 ? 0 : value;    }    override public function get allowRandomSeek():Boolean {        if (! _seekDataStore) return false;        return _seekDataStore.allowRandomSeek();    }    private function isInBuffer(seconds:Number):Boolean {        if (!_seekDataStore.dataAvailable) {            log.debug("No keyframe data available, can only seek inside the buffer");            return true;        }        return bufferStart <= seconds - clip.start && seconds - clip.start <= bufferEnd;    }    private function serverSeek(netStream:NetStream, seconds:Number, setBufferStart:Boolean = true, silent:Boolean = false):void {        log.debug("serverSeek() for clip " + clip);        if (setBufferStart) {            _bufferStart = seconds;        }        _seekDataStore.prevSeekTime = seconds;        var requestUrl:String = appendQueryString(clip.completeUrl, seconds);        log.debug("doing server seek, url " + requestUrl);        if (! silent) {            _serverSeekInProgress = true;        }        netStream.play(requestUrl);    }    private function appendQueryString(url:String, start:Number):String {        return url + _config.queryString.replace("${start}", start == 0 ? 0 : _seekDataStore.getQueryStringStartValue(start));    }    override protected function onMetaData(event:ClipEvent):void {        if (_startSeekDone) {            return;        }        log.info("received metaData for clip" + Clip(event.target));        log.debug("clip is " + clip);        if (!_clipWithKeyframeInfo || _clipWithKeyframeInfo != event.target) {            _seekDataStore = DefaultSeekDataStore.create(event.target as Clip, Clip(event.target).metaData)        }        _clipWithKeyframeInfo = event.target as Clip;        clip.dispatch(ClipEventType.START, pauseAfterStart);        if (pauseAfterStart) {            log.debug("pauseAfterStart is true");            clip.dispatch(ClipEventType.PAUSE);        }        // at this point we seek to the start position if it's greater than zero        if (clip.start > 0) {            log.debug("seeking to start");            serverSeek(netStream, clip.start, true, true);            _startSeekDone = true;        } else if (pauseAfterStart) {            netStream.seek(0);            pauseAfterStart = false;        }    }    override protected function canDispatchBegin():Boolean {        if (_serverSeekInProgress) return false;        if (clip.start > 0 && ! _startSeekDone) return false;        return true;    }    override protected function onNetStatus(event:NetStatusEvent):void {        log.info("onNetStatus: " + event.info.code);        if (event.info.code == "NetStream.Play.Start") {            log.debug("started, will pause after start: " + pauseAfterStart);            // we need to pause here because the stream was started when server-seeking to start pos            if (paused || pauseAfterStart) {                log.info("started: pausing to pos 0 in netStream");                netStream.seek(0);                pause(null);                if (_startSeekDone) {                    pauseAfterStart = false;                }            }            // at this stage the server seek is in target, and we can dispatch the seek event            if (_serverSeekInProgress) {                _serverSeekInProgress = false;                clip.dispatch(ClipEventType.SEEK, seekTarget);            }        }    }    public function getDefaultConfig():Object {        return null;    }}}