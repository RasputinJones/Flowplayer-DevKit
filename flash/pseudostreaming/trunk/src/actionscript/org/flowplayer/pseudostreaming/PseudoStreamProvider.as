/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008 Flowplayer Ltd * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.pseudostreaming {	import org.flowplayer.model.PluginEventType;			import flash.events.NetStatusEvent;	import flash.net.NetStream;		import org.flowplayer.controller.NetStreamControllingStreamProvider;	import org.flowplayer.model.Clip;	import org.flowplayer.model.ClipEvent;	import org.flowplayer.model.ClipEventType;	import org.flowplayer.model.Plugin;	import org.flowplayer.model.PluginModel;	import org.flowplayer.util.Assert;	import org.flowplayer.util.Log;	import org.flowplayer.util.PropertyBinder;	import org.flowplayer.view.Flowplayer;		/**	 * @author api	 */	public class PseudoStreamProvider extends NetStreamControllingStreamProvider implements Plugin {		private var _bufferStart:Number;		private var _config:Config;		private var _keyFrameTimes:Array;		private var _keyFrameFilePositions:Array;		private var _clipWithKeyframeInfo:Clip;		private var _serverSeekInProgress:Boolean;		private var _startSeekDone:Boolean;		private var _model:PluginModel;		/**		 * Called by the player to set my config.		 */		public function onConfig(model:PluginModel):void {			_model = model;			_config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;		}				/**		 * Called by the player to set the Flowplayer API.		 */		public function onLoad(player:Flowplayer):void {			log.info("onLoad, registering metadata listener");			player.playlist.onMetaData(onMetaData, function(clip:Clip):Boolean { return clip.provider == _model.name; });			_model.dispatchOnLoad();					}		override protected function doLoad(event:ClipEvent, netStream:NetStream, clip:Clip):void {			log.info("onStart");			_bufferStart = clip.start;			_startSeekDone = false;			super.doLoad(event, netStream, clip);		}				private function setKeyframeData(metaData:Object):void {			log.debug("extracting keyframe times and filepositions");			for (var prop:String in metaData) {				log.debug(metaData[prop]);			}			try {				Assert.notNull(metaData, "clip does not have any metadata, cannot use pseudostreaming");								var keyFrames:Object = metaData.keyframes;				if (! keyFrames) {					log.info("No keyframes in this file, random seeking cannot be done");					return;				}				_keyFrameTimes = keyFrames.times;				Assert.notNull(_keyFrameTimes, "clip does not have keyframe metadata, cannot use pseudostreaming");								_keyFrameFilePositions = keyFrames.filepositions;				Assert.notNull(_keyFrameFilePositions, "clip does not have keyframe metadata, cannot use pseudostreaming");							} catch (e:Error) {				log.error("error getting keyframes " + e.message);				clip.dispatch(ClipEventType.ERROR, e.message);			}		}		override protected function doSeek(event:ClipEvent, netStream:NetStream, seconds:Number):void {			var target:Number = clip.start + seconds;			if (isInBuffer(target)) {				log.debug("seeking inside buffer, target " + target + " seconds");				netStream.seek(target);			} else {				serverSeek(netStream, target);			} 		}		//		override protected function doStop(event:ClipEvent, netStream:NetStream):void {//			silentSeek = true;//			doSeek(null, netStream, 0);//			netStream.pause();//			dispatchEvent(event);//		}				override public function get bufferStart():Number {			if (! clip) return 0;			return _bufferStart - clip.start;		}		override public function get bufferEnd():Number {			if (! netStream) return 0;			if (! clip) return 0;			return bufferStart + netStream.bytesLoaded/netStream.bytesTotal * (clip.duration - bufferStart);		}		override protected function getCurrentPlayheadTime(netStream:NetStream):Number {			if (! clip) return 0;			var value:Number = netStream.time - clip.start;			return value < 0 ? 0 : value;		}				override public function get allowRandomSeek():Boolean {			return _keyFrameTimes != null && _keyFrameTimes.length > 0;		}		private function getClipUrlWithStartParam(clip:Clip, start:Number = undefined):String {			var url:String = clip.completeUrl;			var startPos:Number = start ? start : clip.start;			if (startPos == 0) return url;			return appendQueryString(url, startPos);		}				private function isInBuffer(seconds:Number):Boolean {			if (!_keyFrameTimes) {				log.debug("No keyframe data available, can only seek inside the buffer");				return true;			}			return bufferStart <= seconds - clip.start && seconds - clip.start <= bufferEnd;		}		private function serverSeek(netStream:NetStream, seconds:Number, setBufferStart:Boolean = true, silent:Boolean = false):void {			if (setBufferStart)				_bufferStart = seconds;			var requestUrl:String = getClipUrlWithStartParam(clip, seconds);			if (requestUrl == null) {				log.warn("No file position correspoonding to target position " + seconds);				return;			} 			log.debug("doing server seek, url " + requestUrl);			if (! silent) {				_serverSeekInProgress = true;			}			netStream.play(requestUrl);		}		private function appendQueryString(url:String, start:Number):String {			var pos:Number = getClosestKeyFrameFilePosition(start);			log.debug("fileposition is " + pos);			return pos >= 0 ? url + _config.queryString.replace("${start}", getClosestKeyFrameFilePosition(start)) : null;		}		private function getClosestKeyFrameFilePosition(seekPosition: Number, rangeBegin:Number = 0, rangeEnd:Number = undefined):Number {			log.debug("finding cosest keyframe position, number of positions available " + _keyFrameFilePositions.length + ", seekPosition " + seekPosition);			if (!rangeEnd) {				rangeEnd = _keyFrameTimes.length;			}			if (rangeBegin == rangeEnd) return _keyFrameFilePositions[rangeBegin]; 						var rangeMid:Number = Math.floor((rangeEnd + rangeBegin)/2); 			if (_keyFrameTimes[rangeMid] >= seekPosition)				return getClosestKeyFrameFilePosition(seekPosition, rangeBegin, rangeMid); 			else				return getClosestKeyFrameFilePosition(seekPosition, rangeMid+1, rangeEnd); 		}				override protected function onMetaData(event:ClipEvent):void {			if (_startSeekDone) {				return;			}						log.info("received metaData for clip" + Clip(event.target));			log.debug("clip is " + clip);			if (!_clipWithKeyframeInfo || _clipWithKeyframeInfo != event.target) {				setKeyframeData(Clip(event.target).metaData);			}			_clipWithKeyframeInfo = event.target as Clip;			clip.dispatch(ClipEventType.START);			if (pauseAfterStart) {				clip.dispatch(ClipEventType.PAUSE);			}						// at this point we seek to the start position if it's greater than zero			log.debug("seeking to start, pausing after start: " + pauseAfterStart);			if (clip.start > 0) {				serverSeek(netStream, clip.start, true, true);				_startSeekDone = true;			} else if (pauseAfterStart) {				netStream.seek(0);				pauseAfterStart = false;			}		}		override protected function canDispatchBegin():Boolean {			if (_serverSeekInProgress) return false;			if (clip.start > 0 && ! _startSeekDone) return false;			return true;		}		override protected function onNetStatus(event:NetStatusEvent):void {			log.info("onNetStatus: " + event.info.code);			if (event.info.code == "NetStream.Play.Start") {				log.debug("started, will pause after start: " + pauseAfterStart);				// we need to pause here because the stream was started when server-seeking to start pos				if (paused || pauseAfterStart) {					log.info("started: pausing to pos 0 in netStream");					netStream.seek(0);					pause(null);					if (_startSeekDone) {						pauseAfterStart = false;					}				}				// at this stage the server seek is in target, and we can dispatch the seek event				if (_serverSeekInProgress) {					_serverSeekInProgress = false;					clip.dispatch(ClipEventType.SEEK, seekTarget);				} 			}		}				public function getDefaultConfig():Object {			return null;		}	}}