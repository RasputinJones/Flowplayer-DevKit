/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com>, Anssi Piirainen Flowplayer Oy * Copyright (c) 2009 Electroteque Multimedia, Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.bwcheck {    import flash.display.DisplayObject;    import flash.events.NetStatusEvent;    import flash.net.NetConnection;    import flash.net.NetStream;	import flash.net.NetStreamPlayOptions;	import flash.net.NetStreamPlayTransitions;    import flash.net.SharedObject;    import flash.utils.Timer;    import flash.utils.getTimer;    import mx.utils.StringUtil;    import org.flowplayer.bwcheck.event.DynamicStreamEvent;    import org.flowplayer.bwcheck.servers.FMSServerClientBandwidth;    import org.flowplayer.bwcheck.servers.HttpServerClientBandwidth;    import org.flowplayer.bwcheck.servers.WowzaServerClientBandwidth;    import org.flowplayer.cluster.RTMPCluster;    import org.flowplayer.controller.ClipURLResolver;    import org.flowplayer.controller.StreamProvider;    import org.flowplayer.model.Clip;    import org.flowplayer.model.ClipEvent;    import org.flowplayer.model.DisplayProperties;    import org.flowplayer.model.Plugin;    import org.flowplayer.model.PluginError;    import org.flowplayer.model.PluginEventType;    import org.flowplayer.model.PluginModel;    import org.flowplayer.util.Log;    import org.flowplayer.util.PropertyBinder;    import org.flowplayer.view.Flowplayer;    import org.red5.flash.bwcheck.IBandwidthDetection;    import org.red5.flash.bwcheck.ServerClientBandwidth;    import org.red5.flash.bwcheck.events.BandwidthDetectEvent;    /**	 * A RTMP stream provider with fallback and clustering support. Supports following:	 * <ul>	 * <li>Starting in the middle of the clip's timeline using the clip.start property.</li>	 * <li>Stopping before the clip file ends using the clip.duration property.</li>	 * <li>Ability to combine a group of clips into one gapless stream.</li>	 * <li>Ability to fallback to a list of servers in a cluster server farm.</li>	 * <li>Ability to recognise, store and leave out any failed servers for a given time.</li>	 * <li>Ability to randomly connect to a server in the servers list mimicking a round robin connection.</li>	 * <li>Works with a traditional load balancing appliance by feeding its host at the top of the list, and direct connections to the servers happen on fallback.</li>	 * </ul>	 * <p>	 * Stream group is configured in a clip like this:	 * <code>	 * { streams: [ { url: 'metacafe', duration: 20 }, { url: 'honda_accord', start: 10, duration: 20 } ] }	 * </code>	 * The group is played back seamlessly as one gapless stream. The individual streams in a group can	 * be cut out from a larger file using the 'start' and 'duration' properties as shown in the example above.	 * 	 * <p> 	 * To enable server fallback a hosts config property is required in the plugins config like this:	 * 	 * hosts: [	 *	       'rtmp://server1.host.com/myapp',	 *	       'rtmp://server2.host.com/myapp',	 *	       'rtmp://server3.host.com/myapp',	 *	      ]	 * 	 * <p>	 * To enable the fallback feature to store (client side) failed servers to prevent reattempting those connections the failureExpiry config property is required like so:	 * failureExpiry: 3000,	 * 	 * <p> This tells the feature to wait for 3000 milliseconds before allowing connection attempts again. 	 * 	 * <p>	 * To enable round robin connections the loadBalanceServers config property requires to be enabled like so:	 * 	 * loadBalanceServers: true	 * 	 * <p>	 * Advanced configurations for the fallback feature can be enabled like so:	 * 	 * connectTimeout: 5000,	 * connectCount: 3	 * encoding: 0	 * 	 * <p> connectTimeout is the time in milliseconds before each reconnection attempt.	 * connectCount is the ammount of times connection reattmps will occur before giving up.	 * encoding is the AMF encoding version either 0 or 3 for AMF3.	 * 	 * <p> Two custom events a fired during connection attempts and fallback, these are:	 * 	 * <ul>	 * <li>RTMPEventType.RECONNECTED - onReconnect</li>	 * <li>RTMPEventType.FAILED - onFailed</li>	 * </ul>	 * 	 * @author danielr	 */	public class BwProvider implements ClipURLResolver, Plugin  {		private var _config:BWConfig;		private var log:Log = new Log(this);		private var _connection:NetConnection;		private var _netStream:NetStream;		private var _resolveSuccessListener:Function;		private var _failureListener:Function;		private var _clip:Clip;		private var _rest:Array;		private var _startAfterConnect:Boolean;		private var _hasDetectedBW:Boolean = false;		private var _detectionClass:Class;		private var _serviceMethod:String;        // TODO: refactor all bitrateProfile releated stuff to a new class called, for example "BitrateStorage" 		private var _bitrateProfile:SharedObject;//		private var _ncURI:String;		protected var _infoTimer:Timer;		private var _start:Number = 0;        private var _model:PluginModel;        protected var _rtmpCluster:RTMPCluster;        protected var _dynamicStream:DynamicStream;        protected var _host:String;        protected var _oldStreamName:String;        private var _player:Flowplayer;        private var _resolving:Boolean;        private var _checkingOnBegin:Boolean;        private var _bitrate:Number;        private var _initFailed:Boolean;        private var _playButton:DisplayObject;        private var _bufferingOnly:Boolean;        private var _dynamic:Boolean;        private var _provider:StreamProvider;        public function onConfig(model:PluginModel):void {            log.debug("onConfig(_)");            _config = new PropertyBinder(new BWConfig(), null).copyProperties(model.config) as BWConfig;            _model = model;            _bitrateProfile = SharedObject.getLocal(_config.bitrateProfileName,"/");            _dynamic = _config.dynamic;            try {                _rtmpCluster = new RTMPCluster(_config);                _rtmpCluster.onFailed(onFailed);            } catch (e:Error) {                model.dispatchError(PluginError.INIT_FAILED, e.message);                _initFailed = true;            }        }        public function onLoad(player:Flowplayer):void {            if (_initFailed) return;            _player = player;            _player.playlist.onStart(                    function(event:ClipEvent):void {                        var clip:Clip = event.target as Clip;                        init(clip.getNetStream(), clip);                        if (_dynamic && ! _dynamicStream) {                            initDynamicStream();                        }                    }                    );            _model.dispatchOnLoad();        }        private function alreadyResolved(clip:Clip):Boolean {            return clip.getCustomProperty("bwcheckResolvedUrl") != null;        }        protected function hasDetectedBW():Boolean {            if (! _config.rememberBitrate) return false;            if (_hasDetectedBW) return true;			if (isRememberedBitrateValid()) return true;			return false;		}		public function set onFailure(listener:Function):void {			_failureListener = listener;		}						protected function onFailed(event:ClipEvent = null):void		{			log.info("Connections failed");            dispatch("onFailed");		}        private function dispatch(event:String):void {            _model.dispatch(PluginEventType.PLUGIN_EVENT, event, _rtmpCluster.currentHost, _rtmpCluster.currentHostIndex);        }				/**		 * Start the bandwidth check connection depending on the serverType.		 * By default the FMS implementation requires a true property to the first of the connection arguments.		 * The other server implementations don't require this as they use AMF service callback methods.		 */		public function doBWConnect():void		{			_connection = new NetConnection();			_connection.addEventListener(NetStatusEvent.NET_STATUS, _onConnectionStatus);            _connection.client = new NullNetConnectionClient();                        _host = _rtmpCluster.host;            if (! _host) {                _model.dispatchError(PluginError.ERROR, "no live hosts to connect to");                return;            }                        log.debug("doBWConnect() " + _host.slice(-5, _host.length).toLowerCase());            // set a listener to be used if connection fails, will connect to another host in the cluster            _rtmpCluster.onReconnected(onRTMPReconnect);            _rtmpCluster.start();            log.debug("_doBwConnect(), connecting to " + _host);            dispatch("onConnect");            log.debug("serverType is " + _config.serverType);            switch(_config.serverType)                    {                case "fms":                    _connection.connect(_host, true);                    break;                case "wowza":                case "red5":                    _connection.connect(_host);                    break;                case "http":                    _connection.connect(null);                    break;                default:                    _connection.connect(null);                    break;            }        }		public function handeNetStatusEvent(event:NetStatusEvent):Boolean		{			return true;		}				protected function _onConnectionStatus(event:NetStatusEvent):void {            if (hasDetectedBW()) return;			            switch (event.info.code)            {                case "NetConnection.Connect.Success":                    log.info("successfully connected to " + _connection.uri);                    _rtmpCluster.stop();                    doDetection();                    break;                //connection has failed, reattempt using the fallback system                case "NetConnection.Connect.Failed":                    log.info("Couldn't connect to " + _connection.uri);                    _rtmpCluster.setFailedServer(_connection.uri);                    _rtmpCluster.stop();                    doBWConnect();                    break;                //connection has closed                case "NetConnection.Connect.Closed":            }		}					/**		 * Determine the server type to choose which way to handle the bandwidth detection and run the detection.		 */		protected function doDetection():void		{			log.debug("detecting bandwidth");			//dispatchEvent(new ClipEvent(BWDetectEventType.DETECT_START));            var detect:IBandwidthDetection;			switch(_config.serverType)			{                case "fms":					detect = new FMSServerClientBandwidth();				    break;				case "wowza":					detect = new WowzaServerClientBandwidth();				    break;				case "red5":					detect = new ServerClientBandwidth();					detect.service = "bwCheckService.onServerClientBWCheck";				    break;				case "http":					detect = new HttpServerClientBandwidth();					HttpServerClientBandwidth(detect).url = _host;				    break;				default:						detect = new HttpServerClientBandwidth();					HttpServerClientBandwidth(detect).url = _host;					break;			}            detect.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE, onServerClientComplete);            detect.addEventListener(BandwidthDetectEvent.DETECT_STATUS, onServerClientStatus);            detect.addEventListener(BandwidthDetectEvent.DETECT_FAILED, onDetectFailed);            detect.connection = _connection;            detect.start();		}				/**		 * Called when a detection has failed		 */		public function onDetectFailed(event:BandwidthDetectEvent):void		{			event.stopPropagation();			log.error("\n Detection failed with error: " + event.info.application + " " + event.info.description);			log.info("using default bitrate " + _config.defaultBitrate);            onBandwidthDetected(getMappedBitrate(_config.defaultBitrate), _config.defaultBitrate);		}				/**		 * Called when a detection has completed and set the bandwidth properties from the returned values		 */		 		public function onServerClientComplete(event:BandwidthDetectEvent):void		{			event.stopPropagation();			log.info("\n\n kbit Down: " + event.info.kbitDown + " Delta Down: " + event.info.deltaDown + " Delta Time: " + event.info.deltaTime + " Latency: " + event.info.latency);			_hasDetectedBW = true;						// Set the detected bandwidth			var bandwidth:Number = event.info.kbitDown;			var mappedBitrate:Number = getMappedBitrate(bandwidth);			log.debug("bandwidth (kbitDown) " + bandwidth);			log.info("mapped to bitrate " + mappedBitrate);			// Store the bitrate to prevent further bitrate detections			rememberBandwidth(bandwidth);            			_connection.close();            onBandwidthDetected(mappedBitrate, bandwidth);        }        private function getMappedBitrate(bandwidth:Number):Number {            return getBitrate(bandwidth, _config.defaultBitrate, _config.closestRateInterval);        }        private function onBandwidthDetected(mappedBitrate:Number, detectedBitrate:Number):void {            _bitrate = mappedBitrate;            if (_playButton && _playButton.hasOwnProperty("stopBuffering")) {                _playButton["stopBuffering"]();            }            // check if we are resolving or just switching streams based on detected BW            if (_checkingOnBegin) {                log.debug("onBandwidthDetected(), checkOnBegin is true, about to set resolved URL and call play");                changeStreamNames(mappedBitrate);                _checkingOnBegin = false;                log.debug("dispatching onBwDone, mapped bitrate: " + mappedBitrate + " detected bitrate " + detectedBitrate + " url: " + _clip.url);                _model.dispatch(PluginEventType.PLUGIN_EVENT, "onBwDone", _clip.url, mappedBitrate, detectedBitrate);                if (_bufferingOnly) {                    _player.startBuffering();                                    } else {                    _player.play();                }                return;            } else if (_resolving) {                changeStreamNames(mappedBitrate);                _resolveSuccessListener(_clip);                _resolving = false;            } else if (_netStream && (_player.isPlaying() || _player.isPaused())) {                switchStream(mappedBitrate);                            } else {                changeStreamNames(mappedBitrate);            }            log.debug("dispatching onBwDone, mapped bitrate: " + mappedBitrate + " detected bitrate " + detectedBitrate + " url: " + _clip.url);            _model.dispatch(PluginEventType.PLUGIN_EVENT, "onBwDone", _clip.url, mappedBitrate, detectedBitrate);        }        private function changeStreamNames(bitrate:Number):void {            _oldStreamName = _clip.url;            var url:String = getClipUrl(_clip, bitrate);            _clip.resolvedUrl = url;            _clip.setCustomProperty("bwcheckResolvedUrl", url);            log.debug("mappedUrl " + url + ", clip.url now " + _clip.url);        }        private function switchStream(bitrate:Number):void {            _bitrate = bitrate;            log.debug("switchStream");            changeStreamNames(bitrate);            if (_netStream.hasOwnProperty("play2")) {                switchStreamDynamic(bitrate);            } else {                log.debug("calling play");                 _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitch", bitrate, _clip.url,  _oldStreamName);                _netStream.play(_clip.url, _config.switchCurrentPosition ? _netStream.time : 0, _clip.duration > 0 ? _clip.duration : -1);            }        }        private function switchStreamDynamic(bitrate:Number):void {            log.debug("doing a dynamic switch");            var options:NetStreamPlayOptions = new NetStreamPlayOptions();            if (_oldStreamName) {                options.oldStreamName = _oldStreamName;                options.transition = NetStreamPlayTransitions.SWITCH;            } else {                options.transition = NetStreamPlayTransitions.RESET;            }            options.streamName = _clip.url;            //if (!_config.switchCurrentPosition) options.start = 0;            _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitch", bitrate, options.streamName,  options.oldStreamName);            log.debug("calling play2");            _netStream.play2(options);        }						/**		 * Called during the bitrate detection checking and return its status		 */		public function onServerClientStatus(event:BandwidthDetectEvent):void		{				if (event.info) {				log.info("\n count: "+event.info.count+ " sent: "+event.info.sent+" timePassed: "+event.info.timePassed+" latency: "+event.info.latency+" cumLatency: " + event.info.cumLatency);				//dispatchEvent(new ClipEvent(BWDetectEventType.DETECT_STATUS));			}		}				protected function onRTMPReconnect():void		{            dispatch("onConnectFailed");            _rtmpCluster.setFailedServer(_host);            _connection.close();            doBWConnect();			log.info("Attempting reconnection");		}				/**		 * Determine the chosen bitrate from a given list of bitrates		 * The default bitrate is chosen on fallback of choosing a rate.		 * The highest possible rate is chosen if a clients bandwidth is above or below the highest rate determined by the closestRateInterval config property.		 */		protected function getBitrate(kBDown:int, defaultBitrate:Number, closestRateInterval:int):Number		{			var largest_rate:Number = _config.bitrates[_config.bitrates.length - 1];			var curStreamID:int = 0;						for (var i:int = _config.bitrates.length - 1; i >= 0; i--) {				if (kBDown >= Number(largest_rate))				{					curStreamID = _config.bitrates.length - 1;					break;				} else if (kBDown >= (_config.bitrates[i] - closestRateInterval)) {					curStreamID = i;					break;				} else if (kBDown < Number(_config.bitrates[i])) {					curStreamID = i;				}			}			return (_config.bitrates[curStreamID] ? _config.bitrates[curStreamID] : defaultBitrate);		}						/**		 * Store the detection and chosen bitrate if the rememberBitrate config property is set.		 */		protected function rememberBandwidth(bw:int):void {			if (_config.rememberBitrate) {                _bitrateProfile.data.bandwidth = bw;                _bitrateProfile.data.timestamp = (new Date()).getTime();                log.debug("stored bandwidth " + bw);            }		}        private function isRememberedBitrateValid():Boolean {            log.debug("isRememberedBitrateValid()");            if (! _bitrateProfile.data.bandwidth) {                log.debug("bandwidth not in SO");                return false;            }            var timestamp:Number = _bitrateProfile.data.timestamp;            if (! timestamp) return false;            var expired:Boolean = ((new Date()).getTime() - timestamp) / 1000 > _config.cacheExpiry;            log.debug("is remembered bitrate expired?: " + expired + (expired ? ", age is " + ((new Date()).getTime() - timestamp) / 1000 : ""));            return ! expired;        }        /**         * Callback from DynamicStream.         * @param event         * @return         */        protected function onSwitchStream(event:DynamicStreamEvent):void		{			switchStream(_config.bitrates[event.info.streamID]);		}				public function resolve(provider:StreamProvider, clip:Clip, successListener:Function):void {            log.debug("resolve " + clip);            if (alreadyResolved(clip)) {                log.debug("resolve(): bandwidth already resolved for clip " + clip + ", will not detect again");                successListener(clip);                return;            }			//_bitrateProfile.clear();            _provider = provider;            _resolving = true;            _resolveSuccessListener = successListener;            init(provider.netStream, clip);            checkBandwidthIfNotDetectedYet();        }        private function checkBandwidthIfNotDetectedYet():void {            if (hasDetectedBW()) {                var bitrate:Number = getMappedBitrate(_bitrateProfile.data.bandwidth);                log.info("using remembered bandwidth " + _bitrateProfile.data.bandwidth + ", maps to bitrate " + bitrate);                onBandwidthDetected(getMappedBitrate(bitrate), bitrate);            } else {                log.debug("not using remembered bandwidth, detecting now");                doBWConnect();            }        }        private function init(netStream:NetStream, clip:Clip):void {            _netStream = netStream;            _clip = clip;            _start = netStream ? netStream.time : 0;        }        private function initDynamicStream():void {            log.debug("initDynamicStream(): starting dynamic bitrate adaptation");            if (_dynamicStream) {                throw new Error("already running dynamic bitrate adaptation!");            }            _dynamic = true;            _dynamicStream = new DynamicStream(_config);            _dynamicStream.addEventListener(DynamicStreamEvent.SWITCH_STREAM, onSwitchStream);            _dynamicStream.netStream = _netStream;            _clip.onStart(_dynamicStream.onStart);            _clip.onStop(_dynamicStream.onStop);            _clip.onBufferEmpty(_dynamicStream.onBufferEmpty);            _clip.onBufferFull(_dynamicStream.onBufferFull);            _clip.onSeek(_dynamicStream.onSeek);            _clip.onPause(_dynamicStream.onPause);            _clip.onResume(_dynamicStream.onResume);            _clip.onError(_dynamicStream.onError);            _dynamicStream.start();        }        private function destroyDynamicStream():void {            log.debug("destroyDynamicStream()");            if (! _dynamicStream) return;            _dynamic = false;            log.debug("destroyDynamicStream(): disabling dynamic bitrate adaptation");            _dynamicStream.removeEventListener(DynamicStreamEvent.SWITCH_STREAM, onSwitchStream);            _clip.unbind(_dynamicStream.onStart);            _clip.unbind(_dynamicStream.onStop);            _clip.unbind(_dynamicStream.onBufferEmpty);            _clip.unbind(_dynamicStream.onBufferFull);            _clip.unbind(_dynamicStream.onSeek);            _clip.unbind(_dynamicStream.onPause);            _clip.unbind(_dynamicStream.onResume);            _clip.unbind(_dynamicStream.onError);            _dynamicStream.stop();            _dynamicStream = null;        }		protected function  getClipUrl(clip:Clip, mappedBitrate:Number):String		{			var name:String;			var ext:String;            var originalUrl:String = clip.url;            if (_config.urlExtension) {                name = originalUrl.substring(0, originalUrl.length - _config.urlExtension.length - 1);                ext = _config.urlExtension;            }			else if (originalUrl.lastIndexOf(".") > 0)			{				name = originalUrl.substring(0,originalUrl.lastIndexOf("."));				ext = originalUrl.substring(originalUrl.lastIndexOf(".") + 1,originalUrl.length);			} else {				name = originalUrl;				ext = "";			}						var file:String = StringUtil.substitute(_config.urlPattern, name, _config.getAlias(mappedBitrate), ext);			log.info("Resolved stream url: " + file);				return file;		}		public static function isRtmpUrl(url:String):Boolean {			return url && url.toLowerCase().indexOf("rtmp") == 0;		}        private function checkCurrentClip():Boolean {            var clip:Clip = _player.playlist.current;            if (_clip == clip) return true;                        if (clip.urlResolvers && clip.urlResolvers.indexOf(_model.name) < 0) {                return false;            }            _clip = clip;            return true;        }        [External]        public function checkBandwidth():void    	{            log.debug("checkBandwidth");            if (! checkCurrentClip()) return;            _start = _provider ? _provider.time : 0;            _hasDetectedBW = false;            doBWConnect();        }		[External]		public function set bitrate(bitrate:Number):void		{            log.debug("set bitrate()");            if (! checkCurrentClip()) return;            _bitrate = bitrate;            try {                if (_player.isPlaying() || _player.isPaused()) {                    switchStream(bitrate);                    destroyDynamicStream();                }            } catch (e:Error) {                log.error("error when switching streams " + e);            }		}        [External]        public function dynamic(enabled:Boolean):void {            log.debug("set dynamic(), currently " + _dynamic +  ", new value" + enabled);            if (_dynamic == enabled) return;                        if (enabled) {                initDynamicStream();            } else {                destroyDynamicStream();            }        }        public function get bitrate():Number {            log.debug("get bitrate()");            if (! checkCurrentClip()) return undefined;            if (_config.rememberBitrate && _bitrateProfile.data.bandwidth >= 0) {                log.debug("get bitrate(), returning remembered bandwidth");                return getMappedBitrate(_bitrateProfile.data.bandwidth);            }            log.debug("get bitrate(), returning current bitrate");            return _bitrate;        }        public function getDefaultConfig():Object {            return null;        }    }}